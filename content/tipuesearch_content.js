var tipuesearch = {"pages": [{'title': '關於', 'text': 'https://github.com/mdecycu/cmsite \n', 'tags': '', 'url': '關於.html'}, {'title': 'w6', 'text': '// 包含標準輸出入程式庫的標頭文件\n// https://blog.csdn.net/weixin_38468077/article/details/101069365\n// http://www.gnuplot.info/demo/\n// https://github.com/sysprog21/rv32emu\n// https://github.com/sysprog21/semu \n// https://docs.google.com/presentation/d/14N0cWG2SnBSqhc2cLF0_2VerB9FF8JN3\n// https://cs61c.org/fa23/\n// https://greenteapress.com/wp/think-python-2e/\n// https://github.com/ecalvadi/c99-examples\n// https://github.com/gouravthakur39/beginners-C-program-examples\n// https://github.com/ergenekonyigit/Numerical-Analysis-Examples\n// https://www.che.ncku.edu.tw/facultyweb/changct/html/teaching/CPPandMATLAB/Past/pdf%20Files/Chap02-Ling.pdf\n// https://gteceducation.com.sg/Brochures/PROGRAMMING/C%20PROGRAMMING%20FULL.pdf\n// https://jsommers.github.io/cbook/cbook.pdf\n// https://jsommers.github.io/cbook/index.html\n// http://student.itee.uq.edu.au/courses/csse2310/CProgrammingNotes.pdf\n// http://cslibrary.stanford.edu/101/EssentialC.pdf\n// https://publications.gbdirect.co.uk/c_book/\n// https://www.fossil-scm.org/fossil-book/doc/2ndEdition/fossilbook.pdf\n// ***** execute on replit \n// cd downloads\n// cc gnuplot_ex1.c -o gnuplot_ex1\n// ./gnuplot_ex1\n#include <stdio.h>\n\n// 主函式\nint main() {\n    // Start a Gnuplot process using popen\n    FILE *gnuplotPipe = popen("gnuplot -persistent", "w");\n    if (!gnuplotPipe) {\n        fprintf(stderr, "Failed to start Gnuplot.\\n");\n        return 1;\n    }\n\n    // Use Gnuplot plotting commands, specify font and output as PNG\n    fprintf(gnuplotPipe, "set terminal png font \'default,10\' size 800,400\\n");\n    fprintf(gnuplotPipe, "set output \'./../images/gnuplot_ex1.png\'\\n");\n    fprintf(gnuplotPipe, "plot sin(x)");\n    // Close popen\n    pclose(gnuplotPipe);\n\n    return 0;\n} \n \xa0 \n', 'tags': '', 'url': 'w6.html'}, {'title': 'w7', 'text': '\n // https://en.wikipedia.org/wiki/Flag_of_thcp2023.a0968899313.repl.coe_Republic_of_China \n// cc roc_flag.c -lgd -lm 連接gd與數學庫 \n// https://www.rapidtables.com/web/color/RGB_Color.html \n// 幾何形狀著色與繪圖練習 \n//以下gd繪畫教學嘗試類似的中華民國國旗，請根據以下計劃內容完成後續的國旗綁定 \n＃包括 \n＃包括 \n#包括 \n \nvoiddraw_roc_flag（gdImagePtr img）； \nvoid draw_white_sun(gdImagePtr img, int x, int y, int size, int color); \n \nint main() { \n//寬度3:高度2 \n整數寬度=1200； \nint 高度 = (int)(寬度*2.0 / 3.0); \n \ngdImagePtr img = gdImageCreateTrueColor(寬度, 高度); \ngdImageAlphaBlending(img, 0); \n \n鄰近_roc_flag（img）； \n \nFILE *outputFile = fopen("./../images/roc_flag.png", "wb"); \n如果（輸出檔== NULL）{ \nfprintf(stderr, "開啟輸出檔時發生錯誤。\\n"); \n回傳1； \ngdImagePngEx \n(img, 輸出檔, 9); \nfclose(輸出檔); \ngdImageDestroy(img); \n回傳0； \n} \n \ndrawroVinc_flag（gdImagePtr img）{ \nint寬度= gdImageSX（img）; \nint 高度 = gdImageSY(img); \nint 紅、白、藍； \nint center_x = (int)(寬度/4); \nint center_y = (int)(高度/4); \nint sun_radius = (int)(寬度/8); \n// 標誌顏色 \n紅色 = gdImageColorAllocate(img, 242, 0, 0);  // \n紅白 = gdImageColorAllocate(img, 255, 255, 255);  // 白色條紋 \n藍色 = gdImageColorAllocate(img, 0, 41, 204);  // 藍色 \n// 紅色自訂區域 \ngdImageFilledRectangle(img, 0, 0, 寬度, 高度, 紅色); \n// 藍色區域 \ngdImageFilledRectangle(img, 0, 0, (int)(寬度/2.0), (int)(高度/2.0), 藍色); \n//目前只出青天白日的直線，請嘗試計算所需的點座標完成國旗繪圖 \ndraw_white_sun(img, center_x, center_y, sun_radius, 白色); \n} \n \nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int color) { \n浮動角度 = 0; \nint fromX, fromY; \nint toX, toY; \nfor (int i=0; i<24; i++){ \n角度+= 5*M_PI*2/12; \n//printf("%.3f", 角度); \ntoX = center_x + cos(角度)*sun_radius; \ntoY = center_y + sin(角度)*sun_radius; \n// 允許i為0時移動到toX, toY，其餘都進行直線起重機 \n如果（我！=0）{ \ngdImageLine(img, fromX, fromY, toX, toY, 顏色); \n} \n從X = 到X; \n從Y = 到Y； \n} \n} \n \n \n \n ＃包括 \n＃包括 \n＃包括 \n \n無效draw_usa_flag（gdImagePtr img）； \nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double spin_angle); \n \nint main() { \n    整數寬度=800； \n    int 高度 = (int)(寬度 / 1.9); \n \n    gdImagePtr img = gdImageCreateTrueColor(寬度, 高度); \n    gdImageAlphaBlending(img, 0); \n \n    各地_美國_標誌（img）； \n \n    FILE *outputFile = fopen("./../images/usa_flag.png", "wb"); \n    如果（輸出檔== NULL）{ \n        fprintf(stderr, "開啟輸出檔時發生錯誤。\\n"); \n        返回1； \n    } \n \n    gdImagePngEx(img, 輸出檔, 9); \n    fclose(輸出檔); \n    gdImageDestroy(img); \n \n    返回0； \n} \n \n無效draw_usa_flag（gdImagePtr img）{ \n    int 寬度 = gdImageSX(img); \n    int 高度 = gdImageSY(img); \n    int 紅、白、藍； \n    // 國旗顏色 \n    紅色 = gdImageColorAllocate(img, 178, 34, 52);  // 紅色條紋 \n    白色 = gdImageColorAllocate(img, 255, 255, 255);  // 白色條紋 \n    藍色 = gdImageColorAllocate(img, 60, 59, 110);  // 藍色 \n \n    int stripe_height = 高度 / 13; \n    int stripe_width = 寬度； \n    int star_size = (int)(0.0308 * 高度);  // 星星大小 \n \n    for (int y = 0; y < 高度; y += stripe_height) { \n        if (y / stripe_height % 2 == 0) { \n            gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, 紅色); \n        }另外{ \n            gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, 白色); \n        } \n    } \n \n    gdImageFilledRectangle(img, 0, 0, 寬度 * 2 / 5, stripe_height * 7, 藍色); \n \n    int star_spacing_x = (int)(0.129 * 高度);  //橫向之間的距離 \n    int star_spacing_y = (int)(0.054 * 高度);  //縱向星星之間的距離 \n    int star_start_x = (int)(0.125 * 高度);  // 星星的起始X位置 \n    int star_start_y = (int)(0.0485 * 高度);  // 最開始的Y位置 \n \n    for (int row = 0; row < 9; row++) { \n        int starPerRow = (行 % 2 == 0) ?  6：5； \n \n        // 計算2、4、6和8排星星的偏移量 \n        int offset_x = (行 % 2 == 0) ?  star_spacing_x / -2 : 0; \n \n        for (int 星號 = 0; 星號 \n            int x = star_start_x + star * star_spacing_x + offset_x; \n \n            // 旋轉角度（以弧度為單位） \n            雙旋轉角度 = M_PI / 5;  // 忘記旋轉多少度 \n \n            int y = star_start_y + 行 * star_spacing_y; \n            draw_star(img, x, y, star_size, 白色, 旋轉角度); \n        } \n    } \n} \n \nvoid draw_star(gdImagePtr img, int x, int y, int 大小, int 顏色, 雙rotation_angle) { \n    gdPoint點[10]； \n \n    for (int i = 0; i < 10; i++) { \n        雙倍角度 = M_PI / 2 + i * 2 * M_PI / 10 + 旋轉角度； \n        int 半徑 = (i % 2 == 0) ?尺寸：尺寸/2； \n        點[i].x = x + 半徑 * cos(角); \n        點[i].y = y + 半徑 * sin(角); \n    } \n \n    // 使用指定的顏色填滿星星 \n    gdImageFilledPolygon(img, 點, 10, 顏色); \n} \n \n \n \n \n \n', 'tags': '', 'url': 'w7.html'}, {'title': 'w8', 'text': '＃包括 \n＃包括 \n＃包括 \n \n實際上無效JapanFlag() { \n整數寬度=300； // 寬度 \n整數=高度200； // 高度 \n半徑=50； // 貨物半徑 \nint 中心X = 150;  // 交易中心X座標 \nint 中心Y = 100;  // 訂單中心Y座標 \n \n// 建立一張24元的彩色圖片 \ngdImagePtr im = gdImageCreateTrueColor(寬度, 高度); \n \n// 設定背景色為白色 \nint 白色 = gdImageColorAllocate(im, 255, 255, 255); \ngdImageFill(im, 0, 0, 白色); \n \n// 設定需求的顏色為紅色 \nint 紅色 = gdImageColorAllocate(im, 255, 0, 0); \n \n// 畫紅色浪漫 \ngdImageFilledEllipse(im, centerX, centerY, 2 * 半徑, 2 * 半徑, 紅色); \n \n//輸出圖片到文件 \n檔 *output = fopen("japanese_flag.png", "wb"); \n如果（輸出== NULL）{ \nfprintf(stderr, "無法開啟檔案寫入。\\n"); \n退出（EXIT_FAILURE）； \n} \n \ngdImagePng(im, 輸出); \n \n// 釋放記憶體 \ngdImageDestroy(im); \nfclose(輸出); \n} \n \nint main() { \n鄰近日本國旗(); \nprintf("創建日本國旗：japanese_flag.png\\n"); \n返回0； \n} \n \n \n \n \n ＃包括 \n＃包括 \n＃包括 \n \nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double spin_angle); \n無效draw_chinese_flag(gdImagePtr img); \n \nint main() { \n整數寬度=300； // 國旗寬度 \n整數高度=200； // 國旗高度 \n \ngdImagePtr im = gdImageCreateTrueColor(寬度, 高度); \ngdImageAlphaBlending(im, 0); \n \n鄰近中文標誌（im）； \n \nFILE *outputFile = fopen("./../images/proc_flag.png", "wb"); \n如果（輸出檔== NULL）{ \nfprintf(stderr, "開啟輸出檔時發生錯誤。\\n"); \n返回1； \n} \n \ngdImagePngEx(im, 輸出檔, 9); \nfclose(輸出檔); \ngdImageDestroy(im); \n \n返回0； \n} \n \nvoid draw_star(gdImagePtr img, int x, int y, int 大小, int 顏色, 雙rotation_angle) { \ngdPoint點[10]； \n \n雙外半徑=大小/2； \n雙內半徑=大小/6； \n雙倍角度 = M_PI / 5.0； \n \nfor (int i = 0; i < 10; i++) { \n雙半徑 = (i % 2 == 0) ?外半徑：內半徑； \n雙 theta = 旋轉角度 + i * 角度； \n點[i].x = x + 半徑 * cos(theta); \n點[i].y = y + 半徑 * sin(theta); \n} \n \ngdImageFilledPolygon(img, 點, 10, 顏色); \n} \n \ndraw_chinese_flag（gdImagePtr img）{ \nint 寬度 = gdImageSX(img); \nint 高度 = gdImageSY(img); \nint紅色、黃色； \n \n紅色 = gdImageColorAllocate(img, 255, 0, 0);  // 紅色背景 \n黃色 = gdImageColorAllocate(img, 255, 255, 0);  // 黃色星星 \n \ngdImageFilledRectangle(img, 0, 0, 寬度, 高度, 紅色); \n \nint star_size = (int)(0.28 * 高度); \nint star_x = (int)(0.165 * 寬度); \nint star_y = (int)(0.265 * 高度); \n \ndraw_star(img, star_x, star_y, star_size, 黃色, 11.0); \n \n雙半徑=0.15*高度； \n雙倍角度 = 360 / 7 * M_PI / 179.0； \n雙旋轉 = -M_PI / 7.5； \nint cx = (int)(0.32 * 寬度); \nint cy = (int)(0.27 * 高度); \n \nfor (int i = -1; i < 3; i++) { \nint x = (int)(cx + 半徑 * cos(i * 角度 + 旋轉)); \nint y = (int)(cy + 半徑 * sin(i * 角度 + 旋轉)); \ndraw_star(img, x, y, 19, 黃色, M_PI / 5.0); \n} \n} \n \n \n \n ＃包括 \n＃包括 \n＃包括 \n \n無效draw_uk_flag（gdImagePtr img）； \nvoid fillTriangle(gdImagePtr img, int x1, int y1, int x2, int y2, int x3, int y3, int color); \n \nint main() { \n整數寬度=1200； \nint 高度 = 寬度 / 2; \n \ngdImagePtr img = gdImageCreateTrueColor(寬度, 高度); \ngdImageAlphaBlending(img, 0); \n \n各地_英國_標誌（img）； \n \nFILE *outputFile = fopen("./../images/uk_flag.png", "wb"); \n如果（輸出檔== NULL）{ \nfprintf(stderr, "開啟輸出檔時發生錯誤。\\n"); \n返回1； \n} \n \ngdImagePngEx(img, 輸出檔, 9); \nfclose(輸出檔); \ngdImageDestroy(img); \n \n返回0； \n} \n \n無效draw_uk_flag（gdImagePtr img）{ \nint 寬度 = gdImageSX(img); \nint 高度 = gdImageSY(img); \n \nint 紅、白、藍； \n紅色 = gdImageColorAllocate(img, 204, 0, 0); \n白色 = gdImageColorAllocate(img, 255, 255, 255); \n藍色 = gdImageColorAllocate(img, 0, 0, 153); \n \ngdImageFilledRectangle(img, 0, 0, 寬度, 高度, 藍色); \n \n// 勢弱斜線 \n{ \nint 線粗度 = 100; \ngdImageSetThickness(img, line_thickness); \n \n// 鄰近白色斜線 \nint x1 = 0，y1 = 600，x2 = 1200，y2 = 0； \ngdImageLine(img, x1, y1, x2, y2, 白色); \n \nx1 = 0，y1 = 0，x2 = 1200，y2 = 600； \ngdImageLine(img, x1, y1, x2, y2, 白色); \n} \n \n// 各地紅色斜線 \n{ \nint 線粗度 = 33; \ngdImageSetThickness(img, line_thickness); \n \n// 各地紅色斜線 \n整數 x1 = 566，y1 = 300，x2 = 1166，y2 = 0； \ngdImageLine(img, x1, y1, x2, y2, 紅色); \n \nx1 = 1233，y1 = 600，x2 = 633，y2 = 300； \ngdImageLine(img, x1, y1, x2, y2, 紅色); \n \nx1 = 566，y1 = 300，x2 = -33，y2 = 0； \ngdImageLine(img, x1, y1, x2, y2, 紅色); \n \nx1 = 600，y1 = 316.5，x2 = 0，y2 = 616.5； \ngdImageLine(img, x1, y1, x2, y2, 紅色); \n} \n \n// 鄰近白色斜線 \n{ \nint 線粗度 = 33; \ngdImageSetThickness(img, line_thickness); \n \n// 勢弱斜線 \nint x1 = 0，y1 = 600，x2 = 1200，y2 = 0； \ngdImageLine(img, x1, y1, x2, y2, 紅色); \n \nx1 = 1200，y1 = 16.5，x2 = 600，y2 = 316.5； \ngdImageLine(img, x1, y1, x2, y2, 白色); \n \nx1 = 0，y1 = 583.5，x2 = 600，y2 = 283.5； \ngdImageLine(img, x1, y1, x2, y2, 白色); \n} \n \n// 不平等白色十字 \nint cross_width = 寬度 / 32; \nint cross_arm_width = 寬度 / 32; \nint center_x = 寬度 / 2; \nint center_y = 高度 / 2; \n \ngdImageFilledRectangle(img, center_x + 2.7 * cross_width, 0, center_x - 2.7 * cross_width, 高度, 白色); \ngdImageFilledRectangle(img, 0, center_y + 2.7 * cross_arm_width, 寬度, center_y - 2.7 * cross_arm_width, 白色); \n \n// 各地紅色十字 \ngdImageFilledRectangle(img, center_x + 1.5 * cross_width, 0, center_x - 1.5 * cross_width, height, red); \ngdImageFilledRectangle(img, 0, center_y + 1.5 * cross_arm_width, 寬度, center_y - 1.5 * cross_arm_width, 紅色); \n} \n \n \n \n ＃包括 \n＃包括 \n \nint main() { \n    // 建立一個新的GD圖片（法國國旗尺寸：900x600） \n    gdImagePtr im = gdImageCreateTrueColor(900, 600); \n \n    // 定義顏色（RGB格式） \n    int 藍色 = gdImageColorAllocate(im, 0, 0, 255); \n    int 白色 = gdImageColorAllocate(im, 255, 255, 255); \n    int 紅色 = gdImageColorAllocate(im, 255, 0, 0); \n \n    // 縱向條紋（3等寬） \n    int 條帶寬度 = 900 / 3; \n    gdImageFilledRectangle(im, 0, 0, stripeWidth - 1, 599, 藍色); \n    gdImageFilledRectangle(im, stripeWidth, 0, 2 * stripeWidth - 1, 599, 白色); \n    gdImageFilledRectangle(im, 2 * stripeWidth, 0, 899, 599, 紅色); \n \n    // 將圖片儲存到檔案中 \n    FILE *outputFile = fopen(“french_flag.png”, “wb”); \n    gdImagePng(im, 輸出檔); \n    fclose(輸出檔); \n \n    // 釋放GD影像 \n    gdImageDestroy(im); \n \n    返回0； \n} \n \n \n #include <gd.h> \n#include <stdio.h> \n#include <數學.h> \n \nint main() { \n    gdImagePtr im； \n    文件*輸出； \n    int 白色、紅色、藍色、黑色； \n \n    im = gdImageCreateTrueColor(600, 400); \n    白色 = gdImageColorAllocate(im, 255, 255, 255); \n    紅色 = gdImageColorAllocate(im, 225, 0, 0); \n    藍色 = gdImageColorAllocate(im, 0, 0, 225); \n    黑色 = gdImageColorAllocate(im, 0, 0, 0); \n \n    // 填滿白色背景 \n    gdImageFilledRectangle(im, 0, 0, 599, 399, 白色); \n \n    // 在中間加入紅藍色各一半的圓，將紅色移到上方，藍色移到下方 \n    int 中心X = 300; \n    int 中心Y = 200; \n    整數半徑=200； \n \n    gdImageFilledArc(im, centerX, centerY, 半徑, 半徑, 0, 180, 藍色, gdPie); \n    gdImageFilledArc(im, centerX, centerY - 1, 半徑, 半徑, 180, 360, 紅色, gdPie); \n \n    // 在中間加入右側偏移49的直徑為100的藍色圓 \n    int 藍色圓半徑 = 50;  // 半徑為50 \n    int offsetX = 49； \n    gdImageFilledEllipse(im, centerX + offsetX, centerY, blueCircleRadius * 2, blueCircleRadius * 2, 藍色); \n \n    // 在中間加入向左偏移50的直徑為100的紅色圓 \n    int 紅色圓半徑 = 50;  // 半徑為50 \n    gdImageFilledEllipse(im, centerX - 49, centerY, redCircleRadius * 2, redCircleRadius * 2, 紅色); \n \n    // 將中間的圖形順時針旋轉104度 \n    雙角 = 104.0； \n    gdImagePtr 旋轉_im = gdImageCreateTrueColor(600, 400); \n    gdImageFilledRectangle(rotated_im, 0, 0, 599, 399, 白色); \n \n    // 複製原始影像 \n    gdImageCopy(rotated_im, im, 0, 0, 0, 0, 600, 400); \n \n    // 逆時針旋轉的角度 \n    雙旋轉角度 = 25.0; \n \n    // 相對斜直的長方形 \n    int 矩形寬度 = 15;  // 長方形寬度 \n    int 矩形高度 = 120;  // 長方形高度 \n    int 矩形間距 = 10;  // 長方形間隔 \n \n    // 計算三個長方形的左上角座標 \n    int rect1X = 139 - 矩形寬度 - 矩形間距； // 第一個長方形 \n    int 矩形1Y = 206 - 矩形高度/2； \n    int 矩形2X = 矩形1X - 矩形寬度 - 矩形間距； // 第二個長方形 \n    int 矩形2Y = 矩形1Y； \n    int 矩形3X = 矩形2X - 矩形寬度 - 矩形間距； // 第三個長方形 \n    int 矩形3Y = 矩形1Y； \n \n    gdPoint點1[4]； \n    點1[0].x = (int)(rect1X - centerX) * cos(rotationAngle * M_PI / 180) - (rect1Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n    點1[0].y = (int)(rect1X - centerX) * sin(rotationAngle * M_PI / 180) + (rect1Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n    點1[1].x = (int)((矩形1X + 矩形寬度) - centerX) * cos(旋轉角度* M_PI / 180) - (矩形1Y - centerY) * sin(旋轉角度* M_PI / 180) + centerX; \n    點1[1].y = (int)((矩形1X + 矩形寬度) - centerX) * sin(旋轉角度* M_PI / 180) + (矩形1Y - centerY) * cos(旋轉角度* M_PI / 180) + centerY; \n    點1[2].x = (int)((矩形1X + 矩形寬度) - centerX) * cos(旋轉角度* M_PI / 180) - ((矩形1Y + 矩形高度) - centerY) * sin(旋轉角度* M_PI / 180) + centerX; \n    點1[2].y = (int)((矩形1X + 矩形寬度) - centerX) * sin(旋轉角度* M_PI / 180) + ((矩形1Y + 矩形高度) - centerY) * cos(旋轉角度* M_PI / 180) + centerY; \n    點1[3].x = (int)(矩形1X - 中心X) * cos(旋轉角度* M_PI / 180) - ((矩形1Y + 矩形高度) - 中心Y) * sin(旋轉角度* M_PI / 180 ) + centerX; \n    點1[3].y = (int)(矩形1X - 中心X) * sin(旋轉角度* M_PI / 180) + ((矩形1Y + 矩形高度) - 中心Y) * cos(旋轉角度* M_PI / 180 ) + centerY; \n \n    gdPoint點2[4]； \n    點2[0].x = (int)(rect2X - centerX) * cos(rotationAngle * M_PI / 180) - (rect2Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n    點2[0].y = (int)(rect2X - centerX) * sin(rotationAngle * M_PI / 180) + (rect2Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n    點2[1].x = (int)((矩形2X + 矩形寬度) - centerX) * cos(rotationAngle * M_PI / 180) - (矩形2Y - centerY) * sin(旋轉角度* M_PI / 180) + centerX ; \n    點2[1].y = (int)((矩形2X + 矩形寬度) - centerX) * sin(旋轉角度* M_PI / 180) + (矩形2Y - centerY) * cos(旋轉角度* M_PI / 180) + centerY; \n    點2[2].x = (int)((矩形2X + 矩形寬度) - centerX) * cos(旋轉角度* M_PI / 180) - ((矩形2Y + 矩形高度) - centerY) * sin(旋轉角度* M_PI / 180) + centerX; \n    點2[2].y = (int)((矩形2X + 矩形寬度) - centerX) * sin(旋轉角度* M_PI / 180) + ((矩形2Y + 矩形高度) - centerY) * cos(旋轉角度* M_PI / 180) + centerY; \n    點2[3].x = (int)(rect2X - centerX) * cos(rotationAngle * M_PI / 180) - ((rect2Y + rectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n    點2[3].y = (int)(rect2X - centerX) * sin(rotationAngle * M_PI / 180) + ((rect2Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n    gdPoint點3[4]； \n    點3[0].x = (int)(rect3X - centerX) * cos(rotationAngle * M_PI / 180) - (rect3Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n    點3[0].y = (int)(rect3X - centerX) * sin(rotationAngle * M_PI / 180) + (rect3Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n    點3[1].x = (int)((rect3X + rectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - (rect3Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n    點3[1].y = (int)((rect3X + rectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + (rect3Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n    點3[2].x = (int)((矩形3X + 矩形寬度) - centerX) * cos(旋轉角度* M_PI / 180) - ((矩形3Y + 矩形高度) - centerY) * sin(旋轉角度* M_PI / 180) + centerX; \n    點3[2].y = (int)((rect3X + rectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect3Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + center ; \n    點3[3].x = (int)(rect3X - centerX) * cos(rotationAngle * M_PI / 180) - ((rect3Y + rectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n    點3[3].y = (int)(rect3X - centerX) * sin(rotationAngle * M_PI / 180) + ((rect3Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n    gdImageFilledPolygon(rotated_im, 點1, 4, 黑色); \n    gdImageFilledPolygon（rotated_im，points2，4，黑色）； \n    gdImageFilledPolygon(rotated_im, 點3, 4, 黑色); \n \n \n  {//新增的黑色斜形 \n  gdPoint rect4Points[4]; \n  int rect4X = 70;  // 第四個長方形 \n  int rect4Y = 185; \n  rect4Points[0].x = (int)(rect4X - centerX) * cos(rotationAngle * M_PI / 180) + (rect4Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4Points[0].y = (int)(rect4X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  int 矩形寬度 = 矩形寬度； // 假設 rectWidth 已經定義 \n  int rect4Height = rectHeight;  // 假設 rectHeight 已經定義 \n  rect4Points[1].x = (int)((rect4X + rect4Width) - centerX) * cos(rotationAngle * M_PI / 180) + (rect4Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4Points[1].y = (int)((rect4X + rect4Width) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  矩形點[2].x = (int)((矩形寬度+ 矩形寬度) - centerX) * cos(旋轉角度* M_PI / 180) + ((矩形Y + 矩形高度) - centerY) * sin(旋轉角度* M_PI / 180) + centerX; \n  矩形點[2].y = (int)((矩形X + 矩形寬度) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((矩形Y + 矩形高度) - centerY) * cos(旋轉角* M_PI / 180) + 中心Y； \n  rect4Points[3].x = (int)(rect4X - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4Y + rect4Height) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  矩形點[3].y = (int)(矩形X - 中心X) * (-sin(旋轉角度* M_PI / 180)) + ((矩形Y + 矩形高度) - 中心Y) * cos(旋轉角度* M_PI / 180) + 中心Y; \n \n  gdImageFilledPolygon(rotated_im, rect4Points, 4, 黑色); \n \n  // 修改第五個斜形 \n  gdPoint rect5Points[4]; \n  int 矩形5X = 矩形4X + 矩形4寬度 + 矩形間距； // 第五個長方形 \n  int 矩形5Y = 矩形4Y； \n  int 中間矩形寬度 = 15;  // 中間長方形寬度 \n  int 中間矩形高度 = 55;  // 中間長方形高度 \n  int 中間矩形間距 = 10;  // 中間長方形兩邊間隔 \n  rect5Points[0].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) + (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect5Points[0].y = (int)(rect5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect5Points[1].x = (int)((rect5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) + (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect5Points[1].y = (int)((rect5X + middleRectWidth) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  矩形點[2].x = (int)((矩形矩形寬度) - centerX) * cos(旋轉角度* M_PI / 180) + ((矩形矩形高度+ 矩形高度) - centerY) * sin(旋轉角度* M_PI / 180) + centerX; \n  矩形點[2].y = (int)((矩形矩形寬度+ 矩形寬度) - 中心X) * (-sin(旋轉角度* M_PI / 180)) + ((矩形矩形高度+ 矩形高度) - 中心Y ) * cos(旋轉角度* M_PI / 180) + 中心Y； \n  rect5Points[3].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) + ((rect5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect5Points[3].y = (int)(rect5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rect5Points, 4, 黑色); \n \n  //新增位於第五個斜形下方的新的黑色斜形 \n  gdPoint rectBelow5Points[4]; \n  int rectBelow5X = rect5X; \n  int 矩形下方5Y = 矩形5Y + 中間矩形高度 + 中間矩形間距； \n  rectBelow5Points[0].x = (int)(rectBelow5X - centerX) * cos(rotationAngle * M_PI / 180) + (rectBelow5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rectBelow5Points[0].y = (int)(rectBelow5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rectBelow5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rectBelow5Points[1].x = (int)((rectBelow5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) + (rectBelow5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rectBelow5Points[1].y = (int)((rectBelow5X + middleRectWidth) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rectBelow5Y - centerY) * cos(rotationAngle * M_PI / 180) + +PI; \n  rectBelow5Points[2].x = (int)((rectBelow5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) + ((rectBelow5Y + middleRectHeight) - centerY) * sin(rotationAngle * MPIPIY + middleRectHeight) - centerY) * sin(rotationAngle * MPIPI +/Xenter \n  rectBelow5Points[2].y = (int)((rectBelow5X + middleRectWidth) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rectBelow5Y + middleRectHeight) - centerY) * cos(rotation 180PI_PI) + 中心Y； \n  rectBelow5Points[3].x = (int)(rectBelow5X - centerX) * cos(rotationAngle * M_PI / 180) + ((rectBelow5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rectBelow5Points[3].y = (int)(rectBelow5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rectBelow5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + center; \n \n  gdImageFilledPolygon(rotated_im, rectBelow5Points, 4, 黑色); \n \n  //新增新的黑色斜形 \n  gdPoint rect6Points[4]; \n  int 矩形6X = 矩形5X + 中間矩形寬度 + 矩形間距； // 第六個長方形 \n  int 矩形6Y = 矩形4Y； \n  rect6Points[0].x = (int)(rect6X - centerX) * cos(rotationAngle * M_PI / 180) + (rect6Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6Points[0].y = (int)(rect6X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  int 矩形寬度=矩形寬度； // 假設 rectWidth 已經定義 \n  int rect6Height = rectHeight;  // 假設 rectHeight 已經定義 \n  rect6Points[1].x = (int)((rect6X + rect6Width) - centerX) * cos(rotationAngle * M_PI / 180) + (rect6Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  矩形點[1].y = (int)((矩形X + 矩形寬度) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (矩形6Y - centerY) * cos(旋轉角度* M_PI / 180 ) + centerY; \n  矩形點[2].x = (int)((矩形寬度+ 矩形寬度) - centerX) * cos(旋轉角度* M_PI / 180) + ((矩形Y + 矩形高度) - centerY) * sin(旋轉角度* M_PI / 180) + centerX; \n  矩形點[2].y = (int)((矩形X + 矩形寬度) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((矩形Y + 矩形高度) - centerY) * cos(旋轉角* M_PI / 180) + 中心Y； \n  rect6Points[3].x = (int)(rect6X - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6Y + rect6Height) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  矩形點[3].y = (int)(矩形X - 中心X) * (-sin(旋轉角度* M_PI / 180)) + ((矩形Y + 矩形高度) - 中心Y) * cos(旋轉角度* M_PI / 180) + 中心Y; \n \n  gdImageFilledPolygon(rotated_im, rect6Points, 4, 黑色);} \n \n  {//增加新的黑色斜形（第四個，上半部） \n  gdPoint rect4aPoints[4]; \n  int rect4aX = 460;  // 第四個長方形（上半部） \n  int rect4aY = 139; \n  rect4aPoints[0].x = (int)(rect4aX - centerX) * cos(rotationAngle * M_PI / 180) + (rect4aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4aPoints[0].y = (int)(rect4aX - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect4aPoints[1].x = (int)((rect4aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect4aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4aPoints[1].y = (int)((rect4aX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect4aPoints[2].x = (int)((rect4aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4aPoints[2].y = (int)((rect4aX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + 中心Y； \n  rect4aPoints[3].x = (int)(rect4aX - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4aPoints[3].y = (int)(rect4aX - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rect4aPoints, 4, 黑色); \n \n  //新增新的黑色斜形（第四個，下半部） \n  gdPoint rect4bPoints[4]; \n  int rect4bX = 460;  // 第四個長方形（下半部） \n  int rect4bY = 139 + 55 + 10； // 上半部的 Y 座標 + 上半部的高度 + 間隔 \n  rect4bPoints[0].x = (int)(rect4bX - centerX) * cos(rotationAngle * M_PI / 180) + (rect4bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4bPoints[0].y = (int)(rect4bX - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect4bPoints[1].x = (int)((rect4bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect4bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4bPoints[1].y = (int)((rect4bX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect4bPoints[2].x = (int)((rect4bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4bPoints[2].y = (int)((rect4bX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + 中心Y； \n  rect4bPoints[3].x = (int)(rect4bX - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4bPoints[3].y = (int)(rect4bX - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rect4bPoints, 4, 黑色); \n \n  // 修改第五個斜形（長度為120） \n  gdPoint rect5Points[4]; \n  int 矩形5X = 矩形4aX + 15 + 矩形間距； // 第五個長方形 \n  int 矩形5Y = 矩形4aY； \n  rect5Points[0].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) + (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect5Points[0].y = (int)(rect5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect5Points[1].x = (int)((rect5X + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect5Points[1].y = (int)((rect5X + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect5Points[2].x = (int)((rect5X + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect5Y + 120) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect5Points[2].y = (int)((rect5X + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect5Y + 120) - centerY) * cos(rotationAngle * M_PI / 180) + 中心Y； \n  rect5Points[3].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) + ((rect5Y + 120) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect5Points[3].y = (int)(rect5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect5Y + 120) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rect5Points, 4, 黑色); \n \n  //新增新的黑色斜形（第六個，上半部） \n  gdPoint rect6aPoints[4]; \n  int 矩形6aX = 矩形5X + 15 + 矩形間距； // 第六個長方形（上半部） \n  int 矩形6aY = 矩形5Y； \n  rect6aPoints[0].x = (int)(rect6aX - centerX) * cos(rotationAngle * M_PI / 180) + (rect6aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6aPoints[0].y = (int)(rect6aX - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect6aPoints[1].x = (int)((rect6aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect6aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6aPoints[1].y = (int)((rect6aX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect6aPoints[2].x = (int)((rect6aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6aPoints[2].y = (int)((rect6aX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + 中心Y； \n  rect6aPoints[3].x = (int)(rect6aX - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6aPoints[3].y = (int)(rect6aX - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rect6aPoints, 4, 黑色); \n \n  //新增新的黑色斜形（第六個，下半部） \n  gdPoint rect6bPoints[4]; \n  int 矩形6bX = 矩形5X + 15 + 矩形間距； // 第六個長方形（下半部） \n  int 矩形6bY = 矩形5Y + 55 + 10； // 上半部的 Y 座標 + 上半部的高度 + 間隔 \n  rect6bPoints[0].x = (int)(rect6bX - centerX) * cos(rotationAngle * M_PI / 180) + (rect6bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6bPoints[0].y = (int)(rect6bX - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect6bPoints[1].x = (int)((rect6bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect6bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6bPoints[1].y = (int)((rect6bX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect6bPoints[2].x = (int)((rect6bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6bPoints[2].y = (int)((rect6bX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + 中心Y； \n  rect6bPoints[3].x = (int)(rect6bX - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6bPoints[3].y = (int)(rect6bX - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rect6bPoints, 4, 黑色);} \n \n \n  //新增新的黑色斜形（第四個，上半部） \n  gdPoint rect4aPoints[4]; \n  int rect4aX = 460;  // 第四個長方形（上半部） \n  int rect4aY = 185; \n  rect4aPoints[0].x = (int)(rect4aX - centerX) * cos(rotationAngle * M_PI / 180) - (rect4aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4aPoints[0].y = (int)(rect4aX - centerX) * sin(rotationAngle * M_PI / 180) + (rect4aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect4aPoints[1].x = (int)((rect4aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - (rect4aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4aPoints[1].y = (int)((rect4aX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + (rect4aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect4aPoints[2].x = (int)((rect4aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect4aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4aPoints[2].y = (int)((rect4aX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect4aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect4aPoints[3].x = (int)(rect4aX - centerX) * cos(rotationAngle * M_PI / 180) - ((rect4aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4aPoints[3].y = (int)(rect4aX - centerX) * sin(rotationAngle * M_PI / 180) + ((rect4aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rect4aPoints, 4, 黑色); \n \n  //新增新的黑色斜形（第四個，下半部） \n  gdPoint rect4bPoints[4]; \n  int rect4bX = rect4aX;  // 使用與上半部相同的X座標 \n  int rect4bY = rect4aY + 55 + 10； // 上半部的 Y 座標 + 上半部的高度 + 間隔 \n  rect4bPoints[0].x = (int)(rect4bX - centerX) * cos(rotationAngle * M_PI / 180) - (rect4bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4bPoints[0].y = (int)(rect4bX - centerX) * sin(rotationAngle * M_PI / 180) + (rect4bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect4bPoints[1].x = (int)((rect4bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - (rect4bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4bPoints[1].y = (int)((rect4bX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + (rect4bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect4bPoints[2].x = (int)((rect4bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect4bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4bPoints[2].y = (int)((rect4bX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect4bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect4bPoints[3].x = (int)(rect4bX - centerX) * cos(rotationAngle * M_PI / 180) - ((rect4bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4bPoints[3].y = (int)(rect4bX - centerX) * sin(rotationAngle * M_PI / 180) + ((rect4bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rect4bPoints, 4, 黑色); \n \n  // 修改第五個斜形（上方加） \n  gdPoint rect5Points[4]; \n  int 矩形5X = 矩形4aX + 15 + 矩形間距； // 第五個長方形 \n  int 矩形5Y = 矩形4aY； \n  int 中間矩形寬度 = 15;  // 中間長方形寬度 \n  int 中間矩形高度 = 55;  // 中間長方形高度 \n  int 中間矩形間距 = 10;  // 中間長方形兩邊間隔 \n  rect5Points[0].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) - (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect5Points[0].y = (int)(rect5X - centerX) * sin(rotationAngle * M_PI / 180) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect5Points[1].x = (int)((rect5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect5Points[1].y = (int)((rect5X + middleRectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  矩形點[2].x = (int)((矩形矩形寬度) - centerX) * cos(旋轉角度* M_PI / 180) - ((矩形矩形高度+ 矩形高度) - centerY) * sin(旋轉角度* M_PI / 180) + centerX; \n  rect5Points[2].y = (int)((rect5X + middleRectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) * cos_PI / 1800); \n  rect5Points[3].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) - ((rect5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect5Points[3].y = (int)(rect5X - centerX) * sin(rotationAngle * M_PI / 180) + ((rect5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rect5Points, 4, 黑色); \n \n \n  //新增位於第五個斜形下方的新的黑色斜形 \n  gdPoint rectBelow5Points[4]; \n  int rectBelow5X = rect5X; \n  int 矩形下方5Y = 矩形5Y + 中間矩形高度 + 中間矩形間距； \n  rectBelow5Points[0].x = (int)(rectBelow5X - centerX) * cos(rotationAngle * M_PI / 180) - (rectBelow5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rectBelow5Points[0].y = (int)(rectBelow5X - centerX) * sin(rotationAngle * M_PI / 180) + (rectBelow5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rectBelow5Points[1].x = (int)((rectBelow5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - (rectBelow5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rectBelow5Points[1].y = (int)((rectBelow5X + middleRectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + (rectBelow5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rectBelow5Points[2].x = (int)((rectBelow5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - ((rectBelow5Y + middleRectHeight) - centerY) * sin(rotationAngle * MPIPIY + middleRectHeight) - centerY) * sin(rotation AAngle MPIPI +/Penter + ) +/AnX); \n  rectBelow5Points[2].y = (int)((rectBelow5X + middleRectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + ((rectBelow5Y + middleRectHeight) - centerY) * cos(rotationAngle * MPI(rotation); \n  rectBelow5Points[3].x = (int)(rectBelow5X - centerX) * cos(rotationAngle * M_PI / 180) - ((rectBelow5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rectBelow5Points[3].y = (int)(rectBelow5X - centerX) * sin(rotationAngle * M_PI / 180) + ((rectBelow5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rectBelow5Points, 4, 黑色); \n \n  // 第六個斜形（上半部） \n  gdPoint rect6aPoints[4]; \n  int 矩形6aX = 矩形5X + 15 + 10； // 第六個長方形（上半部） \n  int 矩形6aY = 矩形5Y； \n  rect6aPoints[0].x = (int)(rect6aX - centerX) * cos(rotationAngle * M_PI / 180) - (rect6aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6aPoints[0].y = (int)(rect6aX - centerX) * sin(rotationAngle * M_PI / 180) + (rect6aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect6aPoints[1].x = (int)((rect6aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - (rect6aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6aPoints[1].y = (int)((rect6aX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + (rect6aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect6aPoints[2].x = (int)((rect6aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect6aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6aPoints[2].y = (int)((rect6aX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect6aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect6aPoints[3].x = (int)(rect6aX - centerX) * cos(rotationAngle * M_PI / 180) - ((rect6aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6aPoints[3].y = (int)(rect6aX - centerX) * sin(rotationAngle * M_PI / 180) + ((rect6aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rect6aPoints, 4, 黑色); \n \n  // 第六個斜形（下半部） \n  gdPoint rect6bPoints[4]; \n  int rect6bX = rect6aX;  // 第六個長方形（下半部） \n  int 矩形 6bY = 矩形 6aY + 55 + 10； // 上半部的 Y 座標 + 上半部的高度 + 間隔 \n  rect6bPoints[0].x = (int)(rect6bX - centerX) * cos(rotationAngle * M_PI / 180) - (rect6bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6bPoints[0].y = (int)(rect6bX - centerX) * sin(rotationAngle * M_PI / 180) + (rect6bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect6bPoints[1].x = (int)((rect6bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - (rect6bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6bPoints[1].y = (int)((rect6bX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + (rect6bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect6bPoints[2].x = (int)((rect6bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect6bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6bPoints[2].y = (int)((rect6bX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect6bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect6bPoints[3].x = (int)(rect6bX - centerX) * cos(rotationAngle * M_PI / 180) - ((rect6bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6bPoints[3].y = (int)(rect6bX - centerX) * sin(rotationAngle * M_PI / 180) + ((rect6bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rect6bPoints, 4, 黑色); \n \n    輸出 = fopen("output.png", "wb"); \n    gdImagePng(rotated_im, 輸出); \n    fclose(輸出); \n \n    gdImageDestroy(im); \n    gdImageDestroy(rotated_im); \n \n    返回0； \n} \n \n \n', 'tags': '', 'url': 'w8.html'}, {'title': 'W11-12', 'text': '＃包括 \n＃包括 \n＃包括 \n \nint main() { \nint 寬度 = 800; \n整數高度=600； \n \ngdImagePtr img = gdImageCreateTrueColor(寬度, 高度); \ngdImageAlphaBlending(img, 0); \n \nFILE *outputFile = fopen("hellogd.png", "wb"); \n如果（輸出檔== NULL）{ \n \nfprintf(stderr, "開啟輸出檔時發生錯誤。\\n"); \n \n返回1； \n} \n \nint 紅色 = gdImageColorAllocate(img, 255, 0, 0); \nint 藍色 = gdImageColorAllocate(img, 0, 0, 255); \nint black = gdImageColorAllocate(img, 0, 0, 0); \nint 白色 = gdImageColorAllocate(img, 255, 255, 255); \n// 長方形著色 \ngdImageFilledRectangle(img, 0, 0, 寬度, 高度, 白色); \ngdImageFilledRectangle(img, 0, 0, (int)width/4, (int)height/4, 藍色); \n// 曲面形著色 \ngdImageFilledEllipse(img, (int)寬度*3/4, (int)高度/4, (int)寬度/4, (int)寬度/4,紅色); \n// 圓形畫線 \ngdImageEllipse(img, (int)寬度*3/4, (int)高度*3/4, (int)寬度/4, (int)寬度/4,紅色); \n// 畫直線 \ngdImageLine(img, (int)width/2, (int)height/2, (int)width/2, (int)height/2 + 100, 藍色); \n \n// 施工畫線 \ngdPoint點[4]； \n點[0].x = (int)寬度/4; \n點[0].y = (int)高度*3/4; \n點[1].x = 點[0].x + 100； \n點[1].y = 點[0].y； \n點[2].x = 點[1].x； \n點[2].y = 點[1].y + 100 ； \n點[3].x = 點[2].x - 100； \n點[3].y = 點[2].y; \ngdImagePolygon(img, 點, 4, 黑色); \n \n// 廈門著色 \ngdPointpoints2[4]; \n點2[0].x = (int)寬度/3; \n點2[0].y = (int)高度/2; \n點2[1].x =點2[0].x + 100； \n點2[1].y = 點2[0].y; \n點2[2].x = 點2[1].x; \n點2[2].y = 點2[1].y + 100； \n點2[3].x = 點2[2].x - 150； \n點2[3].y = 點2[2].y; \ngdImageFilledPolygon(img, 點2, 4, 紅色); \n \ngdImagePngEx(img, 輸出檔, 9); \nfclose(輸出檔); \ngdImageDestroy(img); \n回傳0； \n} \n \n \n \n 先設定hello.c的檔 \n #include <stdio.h> \n \nint main() \n{ \nprintf("你好世界\\n"); \n} \n \n 然後再shell打cc hello.c會出現這個 \n \n 然後要回車這樣replit就會幫我準備好c \n 之後再進行一次程式 cc hello.c，然後打./a.out \n 然後就會出現hello world \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\n// Declare the rotation function\nvoid rotateFilledPolygon(int x_orig, int y_orig, double rotation_ang, gdPoint *points, int num_points) {\n    int i;\n    double angle_rad = rotation_ang * M_PI / 180.0;\n\n    for (i = 0; i < num_points; i++) {\n        int x = points[i].x - x_orig;\n        int y = points[i].y - y_orig;\n\n        points[i].x = x_orig + (int)(x * cos(angle_rad) - y * sin(angle_rad));\n        points[i].y = y_orig + (int)(x * sin(angle_rad) + y * cos(angle_rad));\n    }\n}\n\nint main() {\n    int width = 800;\n    int height = 600;\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    FILE *outputFile = fopen("hellogd2.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n\n    int red = gdImageColorAllocate(img, 255, 0, 0);\n    int blue = gdImageColorAllocate(img, 0, 0, 255);\n    int black = gdImageColorAllocate(img, 0, 0, 0);\n    int white = gdImageColorAllocate(img, 255, 255, 255);\n\n    gdImageFilledRectangle(img, 0, 0, width, height, white);\n    gdImageFilledRectangle(img, 0, 0, (int)width / 4, (int)height / 4, blue);\n\n    gdImageFilledEllipse(img, (int)width * 3 / 4, (int)height / 4, (int)width / 4, (int)width / 4, red);\n    gdImageEllipse(img, (int)width * 3 / 4, (int)height * 3 / 4, (int)width / 4, (int)width / 4, red);\n    gdImageLine(img, (int)width / 2, (int)height / 2, (int)width / 2, (int)height / 2 + 100, blue);\n\n    gdPoint points[4];\n    points[0].x = (int)width / 4;\n    points[0].y = (int)height * 3 / 4;\n    points[1].x = points[0].x + 100;\n    points[1].y = points[0].y;\n    points[2].x = points[1].x;\n    points[2].y = points[1].y + 100;\n    points[3].x = points[2].x - 100;\n    points[3].y = points[2].y;\n\n    // Call the rotation function multiple times\n    for (int i = 0; i < 4; i++) {\n        rotateFilledPolygon((int)width / 4 + 50, (int)height * 3 / 4 + 50, 30.0, points, 4);\n        gdImagePolygon(img, points, 4, black);\n    }\n\n    gdPoint points2[4];\n    points2[0].x = (int)width / 3;\n    points2[0].y = (int)height / 2;\n    points2[1].x = points2[0].x + 100;\n    points2[1].y = points2[0].y;\n    points2[2].x = points2[1].x;\n    points2[2].y = points2[1].y + 100;\n    points2[3].x = points2[2].x - 150;\n    points2[3].y = points2[2].y;\n\n    // Call the rotation function multiple times\n    for (int i = 0; i < 12; i++) {\n        //rotateFilledPolygon((int)width / 3 + 50, (int)height / 2 + 50, 30.0, points2, 4);\n        rotateFilledPolygon(500, 200, 30.0, points2, 4);\n        gdImageFilledPolygon(img, points2, 4, red);\n    }\n\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n\n    return 0;\n} \n', 'tags': '', 'url': 'W11-12.html'}, {'title': 'w13', 'text': '\n #include <stdio.h>\n\xa0\nint main() {\n// 開啟文件以寫入位移和速度數據\nFILE *outputFile = fopen("motion_data.txt", "w");\nif (!outputFile) {\nfprintf(stderr, "無法創建數據文件。\\n");\nreturn 1;\n}\n\xa0\n// 模擬運動 10 秒並計算位移和速度，同時將數據寫入文件\ndouble x = 0.2; // 初始位移\ndouble v = 0.0; // 初始速度\ndouble dt = 0.01; // 時間步長\ndouble t = 0.0; // 時間\n\xa0\nwhile (t <= 10.0) {\ndouble acceleration = (-10.0 * x - 0.5 * v) / 1.0; // 這裡修改了系統的參數\nv += acceleration * dt;\nx += v * dt;\n\xa0\nfprintf(outputFile, "%lf %lf %lf\\n", t, x, v);\n\xa0\nt += dt;\n}\n\xa0\n// 關閉數據文件\nfclose(outputFile);\n\xa0\n// 使用popen啟動Gnuplot進程\nFILE *gnuplotPipe = popen("gnuplot -persistent", "w");\nif (!gnuplotPipe) {\nfprintf(stderr, "無法啟動Gnuplot。\\n");\nreturn 1;\n}\n\xa0\n// 使用Gnuplot繪圖指令，指定字型文件和輸出PNG\nfprintf(gnuplotPipe, "set terminal png font \'default,12\' size 800,400\\n");\nfprintf(gnuplotPipe, "set output \'./../images/motion_plot.png\'\\n");\nfprintf(gnuplotPipe, "set title \'displacement and velocity vs. time\'\\n");\nfprintf(gnuplotPipe, "set xlabel \'time (s)\'\\n");\nfprintf(gnuplotPipe, "set ylabel \'displacement (m)\'\\n");\nfprintf(gnuplotPipe, "plot \'motion_data.txt\' using 1:2 with lines lw 2 title \'displacement\', \\\n\'motion_data.txt\' using 1:3 with lines lw 2 title \'velocity\'\\n");\n\xa0\n// 關閉Gnuplot進程\nfprintf(gnuplotPipe, "exit\\n");\npclose(gnuplotPipe);\n\xa0\nreturn 0;\n} \n \n \n', 'tags': '', 'url': 'w13.html'}, {'title': 'W15', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\n// 定義座標結構\ntypedef struct {\n    double x;\n    double y;\n} Point;\n\nvoid draw_roc_flag(gdImagePtr img);\nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int color);\n\n// 計算圓與線的交點\nvoid circleLineIntersection(double h, double k, double r, double x1, double y1, double x2, double y2);\n\nint main() {\n    // 設定圖片寬度和高度\n    int width = 1200;\n    int height = (int)(width * 2.0 / 3.0);\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    draw_roc_flag(img);\n\n    FILE *outputFile = fopen("roc_flag_in_gd.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n\nvoid draw_roc_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white, blue;\n    int center_x = (int)(width / 4);\n    int center_y = (int)(height / 4);\n    int sun_radius = (int)(width / 8);\n    int white_circle_dia = sun_radius;\n    int blue_circle_dia = white_circle_dia + white_circle_dia * 2 / 15;\n    red = gdImageColorAllocate(img, 255, 0, 0);\n    white = gdImageColorAllocate(img, 255, 255, 255);\n    blue = gdImageColorAllocate(img, 0, 0, 149);\n\n    gdImageFilledRectangle(img, 0, 0, width, height, red);\n    gdImageFilledRectangle(img, 0, 0, (int)(width / 2.0), (int)(height / 2.0), blue);\n\n    draw_white_sun(img, center_x, center_y, sun_radius, white);\n\n    gdImageFilledEllipse(img, center_x, center_y, blue_circle_dia, blue_circle_dia, blue);\n    gdImageFilledEllipse(img, center_x, center_y, white_circle_dia, white_circle_dia, white);\n\n    // 連接第二組ABED的白線\n    int ax = 429;\n    int ay = 125;\n    int bx = 279;\n    int by = 165;\n    int ex = 170;\n    int ey = 274;\n    int dx = 170;\n    int dy = 274;\n\n    // 設定線條寬度\n    gdImageSetThickness(img, 3);\n\n    gdImageLine(img, ax, ay, bx, by, white);\n    gdImageLine(img, bx, by, ex, ey, white);\n    gdImageLine(img, ex, ey, dx, dy, white);\n    gdImageLine(img, dx, dy, ax, ay, white);\n\n    // 新增連線 (ax, ay) 到 (dx, dy)\n    gdImageLine(img, ax, ay, dx, dy, white);\n\n    // 恢復預設線條寬度\n    gdImageSetThickness(img, 1);\n\n    // 利用一個藍色大圓與白色小圓畫出藍色環狀\n    gdImageFilledEllipse(img, center_x, center_y, blue_circle_dia, blue_circle_dia, blue);\n    gdImageFilledEllipse(img, center_x, center_y, white_circle_dia, white_circle_dia, white);\n\n    // 圓的參數\n    double circle_x = (int)(width / 4); // 圓心 x 座標\n    double circle_y = (int)(height / 4); // 圓心 y 座標\n    double radius = white_circle_dia + white_circle_dia * 2 / 15; // 圓半徑\n\n    // 兩點座標\n    double x3 = 170;\n    double y3 = 274;\n    double x4 = 279;\n    double y4 = 165;\n\n    // 計算圓與線段 (x3, y3) 到 (x4, y4) 的交點\n    circleLineIntersection(circle_x, circle_y, radius, x4, y4, x3, y3);\n\n    double x5 = 279;\n    double y5 = 165;\n    double x6 = 429;\n    double y6 = 125;\n\n    // 計算圓與線段 (x6, y6) 到 (x5, y5) 的交點\n    circleLineIntersection(circle_x, circle_y, radius, x6, y6, x5, y5);\n}\n\nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int color) {\n    float deg = M_PI / 180;\n    float sr = sun_radius / tan(75 * deg);\n    int ax, ay, bx, by, dx, dy, ex, ey;\n    gdPoint points[4];\n\n    ax = center_x;\n    ay = center_y - sun_radius;\n    bx = center_x - sun_radius * tan(15 * deg);\n    by = center_y;\n    ex = center_x;\n    ey = center_y + sun_radius;\n    dx = center_x + sun_radius * tan(15 * deg);\n    dy = center_y;\n\n    for (int i = 1; i <= 6; i++) {\n        points[0].x = ax + sun_radius * sin(30 * deg * i);\n        points[0].y = ay + sun_radius - sun_radius * cos(30 * deg * i);\n\n        points[1].x = bx + sr - sr * cos(30 * deg * i);\n        points[1].y = by - sr * sin(30 * deg * i);\n\n        points[2].x = ex - sun_radius * sin(30 * deg * i);\n        points[2].y = ey - (sun_radius - sun_radius * cos(30 * deg * i));\n\n        points[3].x = dx - (sr - sr * cos(30 * deg * i));\n        points[3].y = dy + sr * sin(30 * deg * i);\n\n        gdImageFilledPolygon(img, points, 4, color);\n        gdImagePolygon(img, points, 4, color);\n    }\n}\n\nvoid circleLineIntersection(double h, double k, double r, double x1, double y1, double x2, double y2) {\n    double m = (y2 - y1) / (x2 - x1);\n    double b = y1 - m * x1;\n    double A = 1 + pow(m, 2);\n    double B = 2 * (m * b - m * k - h);\n    double C = pow(k, 2) - pow(r, 2) + pow(h, 2) - 2 * b * k + pow(b, 2);\n\n    double discriminant = pow(B, 2) - 4 * A * C;\n    if (discriminant > 0) {\n        double x_intersect1 = (-B + sqrt(discriminant)) / (2 * A);\n        double y_intersect1 = m * x_intersect1 + b;\n        printf("交點: (%.2f, %.2f)\\n", x_intersect1, y_intersect1);\n\n        double x_intersect2 = (-B - sqrt(discriminant)) / (2 * A);\n        double y_intersect2 = m * x_intersect2 + b;\n        printf("交點: (%.2f, %.2f)\\n", x_intersect2, y_intersect2);\n    } else if (discriminant == 0) {\n        double x_intersect = -B / (2 * A);\n        double y_intersect = m * x_intersect + b;\n        printf("交點: (%.2f, %.2f)\\n", x_intersect, y_intersect);\n    } else {\n        printf("No points.\\n");\n    }\n}\n \n \n \n', 'tags': '', 'url': 'W15.html'}, {'title': 'cEX', 'text': '1. \n #include <stdio.h>\n\nint main()\n{\nfloat a = 0.5;\ndouble b = 1.2;\nint c = 3;\nb = b + a + c;\n\n/* 输出 a, b, c 到屏幕 */\nprintf("a = %3.1f, b = %3.1f, c = %d\\n", a, b, c);\n\nreturn 0;\n} \n \n 2. \n /* ====================\n   字元範例 1\n   ==================== */\n#include <stdio.h>\n\nint main()\n{\n    char x, y;\n\n    x = \'a\';\n    y = (char)97;\n\n    /* 輸出 x, y, x, 最後一個是以 ASCII 值顯示 y */\n    printf("x = %c, y = %c, ASCII of y = %d", x, y, y);\n\n    return 0;\n}\n \n \n 3. \n #include <stdio.h>\n\nint main()\n{\n    int a = 64;\n    int b = 0x40; // 以十六进制表示\n    long c = 64L;\n\n    // 打印变量的值\n    printf("%d, %d, %ld", a, b, c);\n\n    return 0;\n}\n \n \n 4. \n #include <stdio.h>\n\nint main()\n{\n    int a = 10, b = 5;\n\n    // 第一组比较\n    printf("a == b is %d\\n", a == b);\n    printf("a > b is %d\\n", a > b);\n    printf("a < b is %d\\n", a < b);\n    printf("a >= b is %d\\n", a >= b);\n    printf("a <= b is %d\\n", a <= b);\n    printf("a != b is %d\\n", a != b);\n\n    printf("\\n");\n\n    // 修改 b 的值\n    b = 10;\n\n    // 第二组比较\n    printf("a == b is %d\\n", a == b);\n    printf("a > b is %d\\n", a > b);\n    printf("a < b is %d\\n", a < b);\n    printf("a >= b is %d\\n", a >= b);\n    printf("a <= b is %d\\n", a <= b);\n    printf("a != b is %d\\n", a != b);\n\n    return 0;\n}\n \n \n 5. \n #include <stdio.h>\n\nvoid main()\n{\nint a;\n\n// 第一次输出\na = 3;\nprintf("%d\\n", !a); // 逻辑非运算，a为真，所以输出0\n\n// 第二次输出\na = 0;\nprintf("%d\\n", !a); // 逻辑非运算，a为假，所以输出1\n}\n\n \n \n 6. \n #include <stdio.h>\n\nvoid main()\n{\n    char a;\n\n    // 使用 %zu 格式说明符输出 size_t 类型\n    printf("The size of int is %zu\\n", sizeof(int));\n\n    // 使用 %zu 格式说明符输出 size_t 类型\n    printf("The size of char a is %zu\\n", sizeof(a));\n}\n \n \n 7. \n #include <stdio.h>\n\n/* ====================\n计算长方形面积, 需传入长与宽.\n==================== */\nint rect(int x, int y)\n{\n    int result;\n    result = x * y;\n    return result; /* 返回 result */\n}\n\n/* ====================\n主函数\n==================== */\nint main()\n{\n    int x = 8, y = 4;\n    int a;\n    a = rect(x, y);\n    printf("8*4 的面积是 %d", a);\n    return 0;\n}\n \n \n 8. \n #include <stdio.h>\nfloat circle( int r ); /* 宣告 circle 的 prototype */\nvoid main()\n{\nfloat answer;\nanswer = circle(8);\nprintf( " 圓周長度是 %f", answer );\n}\n/* ====================\n circle 函數, 計算 circle 的圓周長\n==================== */\nfloat circle( int r )\n{\nfloat result;\nresult = 3.14159 * (double)1001 * r;\nreturn ( result );\n}\n \n \n 9, \n #include <stdio.h>\n\nint main()\n{\n    char ch;\n\n    printf("输入一个字符：");\n\n    // 检查 scanf 的返回值，确保成功读取一个字符\n    if (scanf(" %c", &ch) != 1) {\n        printf("读取字符失败\\n");\n        return 1; // 或者采取其他错误处理措施\n    }\n\n    if (ch == \'a\') {\n        printf("您按下了 \'a\'\\n");\n    }\n\n    return 0;\n}\n \n \n 10. \n #include <stdio.h>\n\nvoid main()\n{\n    int i;\n\n    // 提示用户输入一个整数\n    printf("100：");\n\n    // 读取用户输入的整数\n    scanf("%d", &i);\n\n    // 判断输入的整数，并输出相应的消息\n    if (i < 100)\n    {\n        printf("i < 100\\n");\n    }\n    else\n    {\n        if ((i >= 100) && (i < 200))\n        {\n            printf("i >= 100 且 i < 200\\n");\n        }\n        else\n        {\n            printf("i >= 200\\n");\n        }\n    }\n}\n \n \n 1.1 \n /* =========================\n function pointer 2\n========================= */\n#include <stdio.h>\n/* ====================\nsay “Hello”.\n==================== */\nvoid Hello(void)\n{\nprintf(“ Hello\\n”);\n}\n/* ====================\nsay “World”.\n==================== */\nvoid World(void)\n{\nprintf(“ World\\n”);\n}\n/* ====================\nmain function.\n==================== */\nint main()\n{\nvoid (*func[3])(void); /* 宣告一個 function pointer array */\nint i = 0 ;\nfunc[0] = Hello; /* 建立 Jumping table */\nfunc[1] = World;\nwhile(1)\n{\nprintf(“Input a number between 0 and 1 : ”);\nscanf( “%d”,&i );\n/* 若 I 大於等於 2 或是小於 0 則離開 loop */\nif( (i >= 2)||(i < 0) )\nbreak;\nelse\nfunc[ i ]( ); /* 執行! */\n}\nreturn 0;\n} \n \n \n \n 1.2 \n   #include <stdio.h>\n\n  /* ====================\n  say “Hello”.\n  ==================== */\n  void Hello(void)\n  {\n      printf("Hello\\n");\n  }\n\n  /* ====================\n  say “World”.\n  ==================== */\n  void World(void)\n  {\n      printf("World\\n");\n  }\n\n  /* ====================\n  main function.\n  ==================== */\n  int main()\n  {\n      void (*func[3])(void); /* 声明一个函数指针数组 */\n      int i = 0;\n\n      func[0] = Hello; /* 建立 Jumping table */\n      func[1] = World;\n\n      while (1)\n      {\n          printf("Input a number between 0 and 1: ");\n          scanf("%d", &i);\n\n          /* 如果 i 大于等于 2 或小于 0 则退出循环 */\n          if (i >= 2 || i < 0)\n              break;\n          else\n              func[i](); /* 执行函数 */\n      }\n\n      return 0;\n  }\n \n \n 1.3 \n #include <stdio.h>\n\n/* ====================\nsay “Hello”.\n==================== */\nvoid Hello(void)\n{\n    printf("Hello\\n");\n}\n\n/* ====================\nsay “World”.\n==================== */\nvoid World(void)\n{\n    printf("World\\n");\n}\n\n/* ====================\nmain function.\n==================== */\nint main()\n{\n    void (*func[3])(void); /* 声明一个函数指针数组 */\n    int i = 0;\n\n    func[0] = Hello; /* 建立 Jumping table */\n    func[1] = World;\n\n    while (1)\n    {\n        printf("Input a number between 0 and 1: ");\n\n        // 检查 scanf 的返回值，确保成功读取一个整数\n        if (scanf("%d", &i) != 1)\n        {\n            printf("无效输入，请输入一个整数。\\n");\n            break;\n        }\n\n        /* 如果 i 大于等于 2 或小于 0 则退出循环 */\n        if (i >= 2 || i < 0)\n            break;\n        else\n            func[i](); /* 执行函数 */\n    }\n\n    return 0;\n}  \n \n 2.1 \n /* ====================\n pointer to pointer – 1.\n==================== */\n#include <stdio.h>\nint main()\n{\nchar *Hello = “Hello”;\nchar *World = “World”;\nchar *GoodBye = “Good Bye”;\nchar *StrArray[3];\nchar **Str;\nint i;\nStr = StrArray;\nStrArray[0] = Hello;\nStrArray[1] = World;\nStrArray[2] = GoodBye;\nfor( i = 0; i < 3; i++ )\n{\nprintf(“%s”, StrArray[ i ] );\n}\nfor( i = 0; i < 3; i++ )\n{\nprintf(“%s”, *Str );\nStr++;\n}\nretur \n 2.2 \n /* ====================\n pointer to pointer – 1.\n==================== */\n#include <stdio.h>\n\nint main() {\n    char *Hello = "Hello";\n    char *World = "World";\n    char *GoodBye = "Good Bye";\n    char *StrArray[3];\n    char **Str;\n    int i;\n\n    Str = StrArray;\n    StrArray[0] = Hello;\n    StrArray[1] = World;\n    StrArray[2] = GoodBye;\n\n    // Print strings using array indexing\n    for (i = 0; i < 3; i++) {\n        printf("%s ", StrArray[i]);\n    }\n\n    // Print strings using pointer arithmetic\n    Str = StrArray;  // Reset the pointer to the beginning\n    for (i = 0; i < 3; i++) {\n        printf("%s ", *Str);\n        Str++;\n    }\n\n    return 0;\n}\n \n \xa0 \n 我的圖片不知道為甚麼不能傳所以我用打字說明 \n 先打cc ex.2-1.c再來打./a.out\xa0Hello World Good Bye Hello World Good Bye\n\n#include <stdio.h>\n\nint main() {\nprintf("int 类型的大小为 %zu 字节\\n", sizeof(int));\n\nchar a;\nprintf("char 类型变量 a 的大小为 %zu 字节\\n", sizeof(a));\n\nreturn 0;\n} \n \n #include <stdio.h>\n\nint main() {\nfloat this_is_a_number1, this_is_a_number2;\nint scanf_result; // Dummy variable to capture scanf\'s return value\n\n/* 读取输入的浮点数 */\nscanf_result = scanf("%f", &this_is_a_number1);\n\n/* 读取输入的浮点数 */\nscanf_result = scanf("%f", &this_is_a_number2);\n\n/* Your code here */\n\nreturn 0;\n}\n\n \n 布萊頓 \n https://en.wikipedia.org/wiki/Python_（程式語言） \n 例子： \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python教學： \n https://docs.python.org/3/tutorial/ \n Python的平衡介紹 \n 縮排（Python採用4個Spaces縮排，以介面執行範圍） \n 變數（ Python 關鍵字 ） \n 註（#單行註解、三單標註或三雙標註標註多行註解） \n 數 (整數 int(), 浮點數 float()) \n 字串 （字符串） \n print (Python 內建函數,  print() 函數式) \n Python是控制流程工具 \n 為了 \n 如果 \n 範圍 \n 開放 \n 讀 \n 清單 \n 元組 \n 字典 \n 功能 \n 嘗試...除了 \n 休息時間 \n 曾經 \n 類別 \n 此頁面示範如何在同一頁面下加入多個線上Ace編輯器與執行按鈕（ practice_html.txt 動態頁面超檔案）。 \n Practice_html.txt 動態頁面超檔案應該可以在啟動Brython時，設定分割.py檔案放入downloads/py目錄中的參考。 \n 也所有出現的反html也使用Brython產生，編寫成 類別 後，在範例匯入時交叉< ai=3>實例 引用。 \n \n<腳本> \n視窗.onload=函數(){ \nbrython({ 調試:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']}); \n} \n</> 腳本 \n 從1累加到100： \n 1加到100 \n 將iterable與iterator 相關說明 ，利用Brython與Ace Editor整理頁面。 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n 文件名稱： .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n 跑步   輸出   明確輸出區 清晰的繪圖區 重新載入 \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從1累加到100第2部分： \n 1加到100 cango_三_齒輪 BS蛇 人工智慧俄羅斯區塊鏈 旋轉塊 \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n 文件名稱： .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n 跑步   輸出   明確輸出區 清晰的繪圖區 重新載入 \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n', 'tags': '', 'url': 'cEX.html'}]};