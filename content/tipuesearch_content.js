var tipuesearch = {"pages": [{'title': '關於', 'text': 'https://github.com/mdecycu/cmsite \n', 'tags': '', 'url': '關於.html'}, {'title': 'w6', 'text': '// 包含標準輸出入程式庫的標頭文件\n// https://blog.csdn.net/weixin_38468077/article/details/101069365\n// http://www.gnuplot.info/demo/\n// https://github.com/sysprog21/rv32emu\n// https://github.com/sysprog21/semu \n// https://docs.google.com/presentation/d/14N0cWG2SnBSqhc2cLF0_2VerB9FF8JN3\n// https://cs61c.org/fa23/\n// https://greenteapress.com/wp/think-python-2e/\n// https://github.com/ecalvadi/c99-examples\n// https://github.com/gouravthakur39/beginners-C-program-examples\n// https://github.com/ergenekonyigit/Numerical-Analysis-Examples\n// https://www.che.ncku.edu.tw/facultyweb/changct/html/teaching/CPPandMATLAB/Past/pdf%20Files/Chap02-Ling.pdf\n// https://gteceducation.com.sg/Brochures/PROGRAMMING/C%20PROGRAMMING%20FULL.pdf\n// https://jsommers.github.io/cbook/cbook.pdf\n// https://jsommers.github.io/cbook/index.html\n// http://student.itee.uq.edu.au/courses/csse2310/CProgrammingNotes.pdf\n// http://cslibrary.stanford.edu/101/EssentialC.pdf\n// https://publications.gbdirect.co.uk/c_book/\n// https://www.fossil-scm.org/fossil-book/doc/2ndEdition/fossilbook.pdf\n// ***** execute on replit \n// cd downloads\n// cc gnuplot_ex1.c -o gnuplot_ex1\n// ./gnuplot_ex1\n#include <stdio.h>\n\n// 主函式\nint main() {\n    // Start a Gnuplot process using popen\n    FILE *gnuplotPipe = popen("gnuplot -persistent", "w");\n    if (!gnuplotPipe) {\n        fprintf(stderr, "Failed to start Gnuplot.\\n");\n        return 1;\n    }\n\n    // Use Gnuplot plotting commands, specify font and output as PNG\n    fprintf(gnuplotPipe, "set terminal png font \'default,10\' size 800,400\\n");\n    fprintf(gnuplotPipe, "set output \'./../images/gnuplot_ex1.png\'\\n");\n    fprintf(gnuplotPipe, "plot sin(x)");\n    // Close popen\n    pclose(gnuplotPipe);\n\n    return 0;\n} \n \xa0 \n', 'tags': '', 'url': 'w6.html'}, {'title': 'w7', 'text': '\n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n \nvoid draw_roc_flag(gdImagePtr img);\nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int white, int red, int blue);\n \nint main() {\n    // width 3: height 2\n    int width = 1200;\n    int height = (int)(width*2.0 / 3.0);\n \n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n \n    draw_roc_flag(img);\n \n    FILE *outputFile = fopen("./roc_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n \nvoid draw_roc_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white, blue;\n    int center_x = (int)(width/4);\n    int center_y = (int)(height/4);\n    int sun_radius = (int)(width/8);\n \n    // Colors for the flag\n    red = gdImageColorAllocate(img, 242, 0, 0); // Red color\n    white = gdImageColorAllocate(img, 255, 255, 255); // White stripes\n    blue = gdImageColorAllocate(img, 0, 41, 204); // Blue\n \n    // 繪製紅色矩形區域\n    gdImageFilledRectangle(img, 0, 0, width, height, red);\n \n    // 繪製藍色矩形區域\n    gdImageFilledRectangle(img, 0, 0, (int)(width/2.0), (int)(height/2.0), blue);\n \n    // 繪製太陽\n    draw_white_sun(img, center_x, center_y, sun_radius, white, red, blue);\n}\nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int white, int red, int blue) {\n    float angle = 0;\n    int numRays = 12; // 光芒的數量\n \n    gdPoint points[3]; // 三個頂點的陣列\n \n    for (int i = 0; i < numRays; i++) {\n        angle = i * (2 * M_PI / numRays);\n        float x1 = center_x + cos(angle) * sun_radius;\n        float y1 = center_y + sin(angle) * sun_radius;\n \n        // 調整兩個底邊頂點的位置\n      float x2 = center_x + cos(angle + 0.35) * (sun_radius * 0.5);\n      float y2 = center_y + sin(angle + 0.35) * (sun_radius * 0.5);\n      float x3 = center_x + cos(angle - 0.35) * (sun_radius * 0.5);\n      float y3 = center_y + sin(angle - 0.35) * (sun_radius * 0.5);\n \n        // 設定多邊形的三個頂點\n        points[0].x = (int)x1;\n        points[0].y = (int)y1;\n        points[1].x = (int)x2;\n        points[1].y = (int)y2;\n        points[2].x = (int)x3;\n        points[2].y = (int)y3;\n \n        gdImageFilledPolygon(img, points, 3, white);\n    }\n  //外圈\n  gdImageFilledEllipse(img, center_x, center_y, sun_radius * 1.2, sun_radius * 1.2, blue);\n   \n    // 繪製太陽內部\n    gdImageFilledEllipse(img, center_x, center_y, sun_radius * 1.1, sun_radius * 1.1, white);\n} \n \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nvoid draw_usa_flag(gdImagePtr img);\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle);\n\nint main() {\n    int width = 800;\n    int height = (int)(width / 1.9);\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    draw_usa_flag(img);\n\n    FILE *outputFile = fopen("./../images/usa_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "打开输出文件时出错。\\n");\n        return 1;\n    }\n\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n\n    return 0;\n}\n\nvoid draw_usa_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white, blue;\n    // 国旗颜色\n    red = gdImageColorAllocate(img, 178, 34, 52); // 红色条纹\n    white = gdImageColorAllocate(img, 255, 255, 255); // 白色条纹\n    blue = gdImageColorAllocate(img, 60, 59, 110); // 蓝色矩形\n\n    int stripe_height = height / 13;\n    int stripe_width = width;\n    int star_size = (int)(0.0308 * height); // 星星大小\n\n    for (int y = 0; y < height; y += stripe_height) {\n        if (y / stripe_height % 2 == 0) {\n            gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, red);\n        } else {\n            gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, white);\n        }\n    }\n\n    gdImageFilledRectangle(img, 0, 0, width * 2 / 5, stripe_height * 7, blue);\n\n    int star_spacing_x = (int)(0.129 * height); // 横向星星之间的间距\n    int star_spacing_y = (int)(0.054 * height); // 纵向星星之间的间距\n    int star_start_x = (int)(0.125 * height); // 星星的起始X位置\n    int star_start_y = (int)(0.0485 * height); // 星星的起始Y位置\n\n    for (int row = 0; row < 9; row++) {\n        int starsPerRow = (row % 2 == 0) ? 6 : 5;\n\n        // 计算2、4、6和8排星星的偏移量\n        int offset_x = (row % 2 == 0) ? star_spacing_x / -2 : 0;\n\n        for (int star = 0; star < starsPerRow; star++) {\n            int x = star_start_x + star * star_spacing_x + offset_x;\n\n            // 旋转角度（以弧度为单位）\n            double rotation_angle = M_PI / 5; // 忘記多少度的旋转\n\n            int y = star_start_y + row * star_spacing_y;\n            draw_star(img, x, y, star_size, white, rotation_angle);\n        }\n    }\n}\n\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle) {\n    gdPoint points[10];\n\n    for (int i = 0; i < 10; i++) {\n        double angle = M_PI / 2 + i * 2 * M_PI / 10 + rotation_angle;\n        int radius = (i % 2 == 0) ? size : size / 2;\n        points[i].x = x + radius * cos(angle);\n        points[i].y = y + radius * sin(angle);\n    }\n\n    // 用指定的颜色填充星星\n    gdImageFilledPolygon(img, points, 10, color);\n} \n \n \n \n \n \n', 'tags': '', 'url': 'w7.html'}, {'title': 'w8', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <stdlib.h>\n\nvoid drawJapaneseFlag() {\n    int width = 300;   // 寬度\n    int height = 200;  // 高度\n    int radius = 50;   // 圓圈半徑\n    int centerX = 150; // 圓圈中心X座標\n    int centerY = 100; // 圓圈中心Y座標\n\n    // 創建一個 24 位的彩色圖片\n    gdImagePtr im = gdImageCreateTrueColor(width, height);\n\n    // 設置背景色為白色\n    int white = gdImageColorAllocate(im, 255, 255, 255);\n    gdImageFill(im, 0, 0, white);\n\n    // 設置圓圈的顏色為紅色\n    int red = gdImageColorAllocate(im, 255, 0, 0);\n\n    // 畫紅色圓圈\n    gdImageFilledEllipse(im, centerX, centerY, 2 * radius, 2 * radius, red);\n\n    // 輸出圖片到檔案\n    FILE *output = fopen("japanese_flag.png", "wb");\n    if (output == NULL) {\n        fprintf(stderr, "Unable to open file for writing.\\n");\n        exit(EXIT_FAILURE);\n    }\n\n    gdImagePng(im, output);\n\n    // 釋放內存\n    gdImageDestroy(im);\n    fclose(output);\n}\n\nint main() {\n    drawJapaneseFlag();\n    printf("Japanese flag created: japanese_flag.png\\n");\n    return 0;\n} \n \n \n #include <stdio.h>\n  #include <gd.h>\n  #include <math.h>\n\n  void draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle);\n  void draw_chinese_flag(gdImagePtr img);\n\n  int main() {\n      int width = 300; // 國旗寬度\n      int height = 200; // 國旗高度\n\n      gdImagePtr im = gdImageCreateTrueColor(width, height);\n      gdImageAlphaBlending(im, 0);\n\n      draw_chinese_flag(im);\n\n      FILE *outputFile = fopen("./../images/proc_flag.png", "wb");\n      if (outputFile == NULL) {\n          fprintf(stderr, "打開輸出文件時出錯。\\n");\n          return 1;\n      }\n\n      gdImagePngEx(im, outputFile, 9);\n      fclose(outputFile);\n      gdImageDestroy(im);\n\n      return 0;\n  }\n\n  void draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle) {\n      gdPoint points[10];\n\n      double outer_radius = size / 2;\n      double inner_radius = size / 6;\n      double angle = M_PI / 5.0;\n\n      for (int i = 0; i < 10; i++) {\n          double radius = (i % 2 == 0) ? outer_radius : inner_radius;\n          double theta = rotation_angle + i * angle;\n          points[i].x = x + radius * cos(theta);\n          points[i].y = y + radius * sin(theta);\n      }\n\n      gdImageFilledPolygon(img, points, 10, color);\n  }\n\n  void draw_chinese_flag(gdImagePtr img) {\n      int width = gdImageSX(img);\n      int height = gdImageSY(img);\n      int red, yellow;\n\n      red = gdImageColorAllocate(img, 255, 0, 0); // 紅色背景\n      yellow = gdImageColorAllocate(img, 255, 255, 0); // 黃色星星\n\n      gdImageFilledRectangle(img, 0, 0, width, height, red);\n\n      int star_size = (int)(0.28 * height);\n      int star_x = (int)(0.165 * width);\n      int star_y = (int)(0.265 * height);\n\n      draw_star(img, star_x, star_y, star_size, yellow, 11.0);\n\n      double radius = 0.15 * height;\n      double angle = 360 / 7 * M_PI / 179.0;\n      double rotation = -M_PI / 7.5;\n      int cx = (int)(0.32 * width);\n      int cy = (int)(0.27 * height);\n\n      for (int i = -1; i < 3; i++) {\n          int x = (int)(cx + radius * cos(i * angle + rotation));\n          int y = (int)(cy + radius * sin(i * angle + rotation));\n          draw_star(img, x, y, 19, yellow, M_PI / 5.0);\n      }\n  }\n \n \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nvoid draw_uk_flag(gdImagePtr img);\nvoid fillTriangle(gdImagePtr img, int x1, int y1, int x2, int y2, int x3, int y3, int color);\n\nint main() {\n    int width = 1200;\n    int height = width / 2;\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    draw_uk_flag(img);\n\n    FILE *outputFile = fopen("./../images/uk_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "打開輸出文件時發生錯誤。\\n");\n        return 1;\n    }\n\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n\n    return 0;\n}\n\nvoid draw_uk_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n\n    int red, white, blue;\n    red = gdImageColorAllocate(img, 204, 0, 0);\n    white = gdImageColorAllocate(img, 255, 255, 255);\n    blue = gdImageColorAllocate(img, 0, 0, 153);\n\n    gdImageFilledRectangle(img, 0, 0, width, height, blue);\n\n    // 繪製斜線\n    {\n        int line_thickness = 100;\n        gdImageSetThickness(img, line_thickness);\n\n        // 繪製白色斜線\n        int x1 = 0, y1 = 600, x2 = 1200, y2 = 0;\n        gdImageLine(img, x1, y1, x2, y2, white);\n\n        x1 = 0, y1 = 0, x2 = 1200, y2 = 600;\n        gdImageLine(img, x1, y1, x2, y2, white);\n    }\n\n    // 繪製紅色斜線\n    {\n        int line_thickness = 33;\n        gdImageSetThickness(img, line_thickness);\n\n        // 繪製紅色斜線\n        int x1 = 566, y1 = 300, x2 = 1166, y2 = 0;\n        gdImageLine(img, x1, y1, x2, y2, red);\n\n        x1 = 1233, y1 = 600, x2 = 633, y2 = 300;\n        gdImageLine(img, x1, y1, x2, y2, red);\n\n        x1 = 566, y1 = 300, x2 = -33, y2 = 0;\n        gdImageLine(img, x1, y1, x2, y2, red);\n\n        x1 = 600, y1 = 316.5, x2 = 0, y2 = 616.5;\n        gdImageLine(img, x1, y1, x2, y2, red);\n    }\n\n    // 繪製白色斜線\n    {\n        int line_thickness = 33;\n        gdImageSetThickness(img, line_thickness);\n\n        // 繪製斜線\n        int x1 = 0, y1 = 600, x2 = 1200, y2 = 0;\n        gdImageLine(img, x1, y1, x2, y2, red);\n\n        x1 = 1200, y1 = 16.5, x2 = 600, y2 = 316.5;\n        gdImageLine(img, x1, y1, x2, y2, white);\n\n        x1 = 0, y1 = 583.5, x2 = 600, y2 = 283.5;\n        gdImageLine(img, x1, y1, x2, y2, white);\n    }\n\n    // 繪製白色十字\n    int cross_width = width / 32;\n    int cross_arm_width = width / 32;\n    int center_x = width / 2;\n    int center_y = height / 2;\n\n    gdImageFilledRectangle(img, center_x + 2.7 * cross_width, 0, center_x - 2.7 * cross_width, height, white);\n    gdImageFilledRectangle(img, 0, center_y + 2.7 * cross_arm_width, width, center_y - 2.7 * cross_arm_width, white);\n\n    // 繪製紅色十字\n    gdImageFilledRectangle(img, center_x + 1.5 * cross_width, 0, center_x - 1.5 * cross_width, height, red);\n    gdImageFilledRectangle(img, 0, center_y + 1.5 * cross_arm_width, width, center_y - 1.5 * cross_arm_width, red);\n}\n \n \n #include <stdio.h>\n#include <gd.h>\n\nint main() {\n    // Create a new GD image (French flag dimensions: 900x600)\n    gdImagePtr im = gdImageCreateTrueColor(900, 600);\n\n    // Define colors (RGB format)\n    int blue = gdImageColorAllocate(im, 0, 0, 255);\n    int white = gdImageColorAllocate(im, 255, 255, 255);\n    int red = gdImageColorAllocate(im, 255, 0, 0);\n\n    // Draw vertical stripes (3 equal-width stripes)\n    int stripeWidth = 900 / 3;\n    gdImageFilledRectangle(im, 0, 0, stripeWidth - 1, 599, blue);\n    gdImageFilledRectangle(im, stripeWidth, 0, 2 * stripeWidth - 1, 599, white);\n    gdImageFilledRectangle(im, 2 * stripeWidth, 0, 899, 599, red);\n\n    // Save the image to a file\n    FILE *outputFile = fopen("french_flag.png", "wb");\n    gdImagePng(im, outputFile);\n    fclose(outputFile);\n\n    // Free the GD image\n    gdImageDestroy(im);\n\n    return 0;\n}\n \n \n #include <gd.h>\n#include <stdio.h>\n#include <math.h>\n\nint main() {\n    gdImagePtr im;\n    FILE *output;\n    int white, red, blue, black;\n\n    im = gdImageCreateTrueColor(600, 400);\n    white = gdImageColorAllocate(im, 255, 255, 255);\n    red = gdImageColorAllocate(im, 225, 0, 0);\n    blue = gdImageColorAllocate(im, 0, 0, 225);\n    black = gdImageColorAllocate(im, 0, 0, 0);\n\n    // 填充白色背景\n    gdImageFilledRectangle(im, 0, 0, 599, 399, white);\n\n    // 在中間添加紅藍各一半的圓，將紅色移到上方，藍色移到下方\n    int centerX = 300;\n    int centerY = 200;\n    int radius = 200;\n\n    gdImageFilledArc(im, centerX, centerY, radius, radius, 0, 180, blue, gdPie);\n    gdImageFilledArc(im, centerX, centerY - 1, radius, radius, 180, 360, red, gdPie);\n\n    // 在中間添加向右偏移49的直徑為100的藍色圓\n    int blueCircleRadius = 50; // 半徑為50\n    int offsetX = 49;\n    gdImageFilledEllipse(im, centerX + offsetX, centerY, blueCircleRadius * 2, blueCircleRadius * 2, blue);\n\n    // 在中間添加向左偏移50的直徑為100的紅色圓\n    int redCircleRadius = 50; // 半徑為50\n    gdImageFilledEllipse(im, centerX - 49, centerY, redCircleRadius * 2, redCircleRadius * 2, red);\n\n    // 將中間的圖形順時針旋轉104度\n    double angle = 104.0;\n    gdImagePtr rotated_im = gdImageCreateTrueColor(600, 400);\n    gdImageFilledRectangle(rotated_im, 0, 0, 599, 399, white);\n\n    // 複製原始圖像\n    gdImageCopy(rotated_im, im, 0, 0, 0, 0, 600, 400);\n\n    // 逆時針旋轉的角度\n    double rotationAngle = 25.0; \n\n    // 繪製斜直的長方形\n    int rectWidth = 15;   // 長方形寬度\n    int rectHeight = 120;  // 長方形高度\n    int rectSpacing = 10;  // 長方形間隔\n\n    // 計算三個長方形的左上角座標\n    int rect1X = 139 - rectWidth - rectSpacing;  // 第一個長方形\n    int rect1Y = 206 - rectHeight / 2;\n    int rect2X = rect1X - rectWidth - rectSpacing;  // 第二個長方形\n    int rect2Y = rect1Y;\n    int rect3X = rect2X - rectWidth - rectSpacing;  // 第三個長方形\n    int rect3Y = rect1Y;\n\n    gdPoint points1[4];\n    points1[0].x = (int)(rect1X - centerX) * cos(rotationAngle * M_PI / 180) - (rect1Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points1[0].y = (int)(rect1X - centerX) * sin(rotationAngle * M_PI / 180) + (rect1Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points1[1].x = (int)((rect1X + rectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - (rect1Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points1[1].y = (int)((rect1X + rectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + (rect1Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points1[2].x = (int)((rect1X + rectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect1Y + rectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points1[2].y = (int)((rect1X + rectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect1Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points1[3].x = (int)(rect1X - centerX) * cos(rotationAngle * M_PI / 180) - ((rect1Y + rectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points1[3].y = (int)(rect1X - centerX) * sin(rotationAngle * M_PI / 180) + ((rect1Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n    gdPoint points2[4];\n    points2[0].x = (int)(rect2X - centerX) * cos(rotationAngle * M_PI / 180) - (rect2Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points2[0].y = (int)(rect2X - centerX) * sin(rotationAngle * M_PI / 180) + (rect2Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points2[1].x = (int)((rect2X + rectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - (rect2Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points2[1].y = (int)((rect2X + rectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + (rect2Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points2[2].x = (int)((rect2X + rectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect2Y + rectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points2[2].y = (int)((rect2X + rectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect2Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points2[3].x = (int)(rect2X - centerX) * cos(rotationAngle * M_PI / 180) - ((rect2Y + rectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points2[3].y = (int)(rect2X - centerX) * sin(rotationAngle * M_PI / 180) + ((rect2Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n    gdPoint points3[4];\n    points3[0].x = (int)(rect3X - centerX) * cos(rotationAngle * M_PI / 180) - (rect3Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points3[0].y = (int)(rect3X - centerX) * sin(rotationAngle * M_PI / 180) + (rect3Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points3[1].x = (int)((rect3X + rectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - (rect3Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points3[1].y = (int)((rect3X + rectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + (rect3Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points3[2].x = (int)((rect3X + rectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect3Y + rectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points3[2].y = (int)((rect3X + rectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect3Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points3[3].x = (int)(rect3X - centerX) * cos(rotationAngle * M_PI / 180) - ((rect3Y + rectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points3[3].y = (int)(rect3X - centerX) * sin(rotationAngle * M_PI / 180) + ((rect3Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n    gdImageFilledPolygon(rotated_im, points1, 4, black);\n    gdImageFilledPolygon(rotated_im, points2, 4, black);\n    gdImageFilledPolygon(rotated_im, points3, 4, black);\n\n\n  {// 添加新的黑色斜形\n  gdPoint rect4Points[4];\n  int rect4X = 70;  // 第四個長方形\n  int rect4Y = 185;\n  rect4Points[0].x = (int)(rect4X - centerX) * cos(rotationAngle * M_PI / 180) + (rect4Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4Points[0].y = (int)(rect4X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  int rect4Width = rectWidth;  // 假設 rectWidth 已經定義\n  int rect4Height = rectHeight;  // 假設 rectHeight 已經定義\n  rect4Points[1].x = (int)((rect4X + rect4Width) - centerX) * cos(rotationAngle * M_PI / 180) + (rect4Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4Points[1].y = (int)((rect4X + rect4Width) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4Points[2].x = (int)((rect4X + rect4Width) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4Y + rect4Height) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4Points[2].y = (int)((rect4X + rect4Width) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4Y + rect4Height) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4Points[3].x = (int)(rect4X - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4Y + rect4Height) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4Points[3].y = (int)(rect4X - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4Y + rect4Height) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect4Points, 4, black);\n\n  // 修改第五個斜形\n  gdPoint rect5Points[4];\n  int rect5X = rect4X + rect4Width + rectSpacing;  // 第五個長方形\n  int rect5Y = rect4Y;\n  int middleRectWidth = 15;    // 中間長方形寬度\n  int middleRectHeight = 55;   // 中間長方形高度\n  int middleRectSpacing = 10;  // 中間長方形上下間隔\n  rect5Points[0].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) + (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[0].y = (int)(rect5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[1].x = (int)((rect5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) + (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[1].y = (int)((rect5X + middleRectWidth) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[2].x = (int)((rect5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[2].y = (int)((rect5X + middleRectWidth) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[3].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) + ((rect5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[3].y = (int)(rect5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect5Points, 4, black);\n\n  // 添加位於第五個斜形下方的新的黑色斜形\n  gdPoint rectBelow5Points[4];\n  int rectBelow5X = rect5X;\n  int rectBelow5Y = rect5Y + middleRectHeight + middleRectSpacing;\n  rectBelow5Points[0].x = (int)(rectBelow5X - centerX) * cos(rotationAngle * M_PI / 180) + (rectBelow5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[0].y = (int)(rectBelow5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rectBelow5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rectBelow5Points[1].x = (int)((rectBelow5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) + (rectBelow5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[1].y = (int)((rectBelow5X + middleRectWidth) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rectBelow5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rectBelow5Points[2].x = (int)((rectBelow5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) + ((rectBelow5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[2].y = (int)((rectBelow5X + middleRectWidth) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rectBelow5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rectBelow5Points[3].x = (int)(rectBelow5X - centerX) * cos(rotationAngle * M_PI / 180) + ((rectBelow5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[3].y = (int)(rectBelow5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rectBelow5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rectBelow5Points, 4, black);\n\n  // 添加新的黑色斜形\n  gdPoint rect6Points[4];\n  int rect6X = rect5X + middleRectWidth + rectSpacing;  // 第六個長方形\n  int rect6Y = rect4Y;\n  rect6Points[0].x = (int)(rect6X - centerX) * cos(rotationAngle * M_PI / 180) + (rect6Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6Points[0].y = (int)(rect6X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  int rect6Width = rectWidth;  // 假設 rectWidth 已經定義\n  int rect6Height = rectHeight;  // 假設 rectHeight 已經定義\n  rect6Points[1].x = (int)((rect6X + rect6Width) - centerX) * cos(rotationAngle * M_PI / 180) + (rect6Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6Points[1].y = (int)((rect6X + rect6Width) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6Points[2].x = (int)((rect6X + rect6Width) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6Y + rect6Height) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6Points[2].y = (int)((rect6X + rect6Width) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6Y + rect6Height) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6Points[3].x = (int)(rect6X - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6Y + rect6Height) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6Points[3].y = (int)(rect6X - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6Y + rect6Height) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect6Points, 4, black);}\n\n  {// 添加新的黑色斜形（第四個，上半部分）\n  gdPoint rect4aPoints[4];\n  int rect4aX = 460;  // 第四個長方形（上半部分）\n  int rect4aY = 139;\n  rect4aPoints[0].x = (int)(rect4aX - centerX) * cos(rotationAngle * M_PI / 180) + (rect4aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[0].y = (int)(rect4aX - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4aPoints[1].x = (int)((rect4aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect4aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[1].y = (int)((rect4aX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4aPoints[2].x = (int)((rect4aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[2].y = (int)((rect4aX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4aPoints[3].x = (int)(rect4aX - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[3].y = (int)(rect4aX - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect4aPoints, 4, black);\n\n  // 添加新的黑色斜形（第四個，下半部分）\n  gdPoint rect4bPoints[4];\n  int rect4bX = 460;  // 第四個長方形（下半部分）\n  int rect4bY = 139 + 55 + 10;  // 上半部分的 Y 座標 + 上半部分的高度 + 間隔\n  rect4bPoints[0].x = (int)(rect4bX - centerX) * cos(rotationAngle * M_PI / 180) + (rect4bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[0].y = (int)(rect4bX - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4bPoints[1].x = (int)((rect4bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect4bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[1].y = (int)((rect4bX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4bPoints[2].x = (int)((rect4bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[2].y = (int)((rect4bX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4bPoints[3].x = (int)(rect4bX - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[3].y = (int)(rect4bX - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect4bPoints, 4, black);\n\n  // 修改第五個斜形（長度為 120）\n  gdPoint rect5Points[4];\n  int rect5X = rect4aX + 15 + rectSpacing;  // 第五個長方形\n  int rect5Y = rect4aY;\n  rect5Points[0].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) + (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[0].y = (int)(rect5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[1].x = (int)((rect5X + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[1].y = (int)((rect5X + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[2].x = (int)((rect5X + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect5Y + 120) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[2].y = (int)((rect5X + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect5Y + 120) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[3].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) + ((rect5Y + 120) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[3].y = (int)(rect5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect5Y + 120) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect5Points, 4, black);\n\n  // 添加新的黑色斜形（第六個，上半部分）\n  gdPoint rect6aPoints[4];\n  int rect6aX = rect5X + 15 + rectSpacing;  // 第六個長方形（上半部分）\n  int rect6aY = rect5Y;\n  rect6aPoints[0].x = (int)(rect6aX - centerX) * cos(rotationAngle * M_PI / 180) + (rect6aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[0].y = (int)(rect6aX - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6aPoints[1].x = (int)((rect6aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect6aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[1].y = (int)((rect6aX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6aPoints[2].x = (int)((rect6aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[2].y = (int)((rect6aX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6aPoints[3].x = (int)(rect6aX - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[3].y = (int)(rect6aX - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect6aPoints, 4, black);\n\n  // 添加新的黑色斜形（第六個，下半部分）\n  gdPoint rect6bPoints[4];\n  int rect6bX = rect5X + 15 + rectSpacing;  // 第六個長方形（下半部分）\n  int rect6bY = rect5Y + 55 + 10;  // 上半部分的 Y 座標 + 上半部分的高度 + 間隔\n  rect6bPoints[0].x = (int)(rect6bX - centerX) * cos(rotationAngle * M_PI / 180) + (rect6bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[0].y = (int)(rect6bX - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6bPoints[1].x = (int)((rect6bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect6bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[1].y = (int)((rect6bX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6bPoints[2].x = (int)((rect6bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[2].y = (int)((rect6bX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6bPoints[3].x = (int)(rect6bX - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[3].y = (int)(rect6bX - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect6bPoints, 4, black);}\n\n\n  // 添加新的黑色斜形（第四個，上半部分）\n  gdPoint rect4aPoints[4];\n  int rect4aX = 460;  // 第四個長方形（上半部分）\n  int rect4aY =185;\n  rect4aPoints[0].x = (int)(rect4aX - centerX) * cos(rotationAngle * M_PI / 180) - (rect4aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[0].y = (int)(rect4aX - centerX) * sin(rotationAngle * M_PI / 180) + (rect4aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4aPoints[1].x = (int)((rect4aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - (rect4aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[1].y = (int)((rect4aX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + (rect4aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4aPoints[2].x = (int)((rect4aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect4aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[2].y = (int)((rect4aX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect4aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4aPoints[3].x = (int)(rect4aX - centerX) * cos(rotationAngle * M_PI / 180) - ((rect4aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[3].y = (int)(rect4aX - centerX) * sin(rotationAngle * M_PI / 180) + ((rect4aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect4aPoints, 4, black);\n\n  // 添加新的黑色斜形（第四個，下半部分）\n  gdPoint rect4bPoints[4];\n  int rect4bX = rect4aX;  // 使用与上半部分相同的X坐标\n  int rect4bY = rect4aY + 55 + 10;  // 上半部分的 Y 座標 + 上半部分的高度 + 間隔\n  rect4bPoints[0].x = (int)(rect4bX - centerX) * cos(rotationAngle * M_PI / 180) - (rect4bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[0].y = (int)(rect4bX - centerX) * sin(rotationAngle * M_PI / 180) + (rect4bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4bPoints[1].x = (int)((rect4bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - (rect4bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[1].y = (int)((rect4bX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + (rect4bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4bPoints[2].x = (int)((rect4bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect4bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[2].y = (int)((rect4bX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect4bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4bPoints[3].x = (int)(rect4bX - centerX) * cos(rotationAngle * M_PI / 180) - ((rect4bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[3].y = (int)(rect4bX - centerX) * sin(rotationAngle * M_PI / 180) + ((rect4bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect4bPoints, 4, black);\n\n  // 修改第五個斜形（在上方添加）\n  gdPoint rect5Points[4];\n  int rect5X = rect4aX + 15 + rectSpacing;  // 第五個長方形\n  int rect5Y = rect4aY;\n  int middleRectWidth = 15;    // 中間長方形寬度\n  int middleRectHeight = 55;   // 中間長方形高度\n  int middleRectSpacing = 10;  // 中間長方形上下間隔\n  rect5Points[0].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) - (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[0].y = (int)(rect5X - centerX) * sin(rotationAngle * M_PI / 180) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[1].x = (int)((rect5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[1].y = (int)((rect5X + middleRectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[2].x = (int)((rect5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[2].y = (int)((rect5X + middleRectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[3].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) - ((rect5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[3].y = (int)(rect5X - centerX) * sin(rotationAngle * M_PI / 180) + ((rect5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect5Points, 4, black);\n\n\n  // 添加位於第五個斜形下方的新的黑色斜形\n  gdPoint rectBelow5Points[4];\n  int rectBelow5X = rect5X;\n  int rectBelow5Y = rect5Y + middleRectHeight + middleRectSpacing;\n  rectBelow5Points[0].x = (int)(rectBelow5X - centerX) * cos(rotationAngle * M_PI / 180) - (rectBelow5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[0].y = (int)(rectBelow5X - centerX) * sin(rotationAngle * M_PI / 180) + (rectBelow5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rectBelow5Points[1].x = (int)((rectBelow5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - (rectBelow5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[1].y = (int)((rectBelow5X + middleRectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + (rectBelow5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rectBelow5Points[2].x = (int)((rectBelow5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - ((rectBelow5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[2].y = (int)((rectBelow5X + middleRectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + ((rectBelow5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rectBelow5Points[3].x = (int)(rectBelow5X - centerX) * cos(rotationAngle * M_PI / 180) - ((rectBelow5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[3].y = (int)(rectBelow5X - centerX) * sin(rotationAngle * M_PI / 180) + ((rectBelow5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rectBelow5Points, 4, black);\n\n  // 第六個斜形（上半部分）\n  gdPoint rect6aPoints[4];\n  int rect6aX = rect5X + 15 + 10;  // 第六個長方形（上半部分）\n  int rect6aY = rect5Y;\n  rect6aPoints[0].x = (int)(rect6aX - centerX) * cos(rotationAngle * M_PI / 180) - (rect6aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[0].y = (int)(rect6aX - centerX) * sin(rotationAngle * M_PI / 180) + (rect6aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6aPoints[1].x = (int)((rect6aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - (rect6aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[1].y = (int)((rect6aX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + (rect6aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6aPoints[2].x = (int)((rect6aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect6aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[2].y = (int)((rect6aX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect6aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6aPoints[3].x = (int)(rect6aX - centerX) * cos(rotationAngle * M_PI / 180) - ((rect6aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[3].y = (int)(rect6aX - centerX) * sin(rotationAngle * M_PI / 180) + ((rect6aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect6aPoints, 4, black);\n\n  // 第六個斜形（下半部分）\n  gdPoint rect6bPoints[4];\n  int rect6bX = rect6aX;  // 第六個長方形（下半部分）\n  int rect6bY = rect6aY + 55 + 10;  // 上半部分的 Y 座標 + 上半部分的高度 + 間隔\n  rect6bPoints[0].x = (int)(rect6bX - centerX) * cos(rotationAngle * M_PI / 180) - (rect6bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[0].y = (int)(rect6bX - centerX) * sin(rotationAngle * M_PI / 180) + (rect6bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6bPoints[1].x = (int)((rect6bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - (rect6bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[1].y = (int)((rect6bX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + (rect6bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6bPoints[2].x = (int)((rect6bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect6bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[2].y = (int)((rect6bX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect6bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6bPoints[3].x = (int)(rect6bX - centerX) * cos(rotationAngle * M_PI / 180) - ((rect6bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[3].y = (int)(rect6bX - centerX) * sin(rotationAngle * M_PI / 180) + ((rect6bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect6bPoints, 4, black);\n\n    output = fopen("output.png", "wb");\n    gdImagePng(rotated_im, output);\n    fclose(output);\n\n    gdImageDestroy(im);\n    gdImageDestroy(rotated_im);\n\n    return 0;\n}\n \n \n', 'tags': '', 'url': 'w8.html'}, {'title': 'W11-12', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\n// Declare the rotation function\nvoid rotateFilledPolygon(int x_orig, int y_orig, double rotation_ang, gdPoint *points, int num_points) {\n    int i;\n    double angle_rad = rotation_ang * M_PI / 180.0;\n\n    for (i = 0; i < num_points; i++) {\n        int x = points[i].x - x_orig;\n        int y = points[i].y - y_orig;\n\n        points[i].x = x_orig + (int)(x * cos(angle_rad) - y * sin(angle_rad));\n        points[i].y = y_orig + (int)(x * sin(angle_rad) + y * cos(angle_rad));\n    }\n}\n\nint main() {\n    // Image dimensions\n    int width = 800;\n    int height = 600;\n\n    // Create a true-color image\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    // Open the output file\n    FILE *outputFile = fopen("hellogd1.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n\n    // Define color indices\n    int red = gdImageColorAllocate(img, 255, 0, 0);\n    int blue = gdImageColorAllocate(img, 0, 0, 255);\n    int black = gdImageColorAllocate(img, 0, 0, 0);\n    int white = gdImageColorAllocate(img, 255, 255, 255);\n\n    // Draw filled rectangles, ellipse, line, and polygons\n    gdImageFilledRectangle(img, 0, 0, width, height, white);\n    gdImageFilledRectangle(img, 0, 0, (int)width / 4, (int)height / 4, blue);\n\n    gdImageFilledEllipse(img, (int)width * 3 / 4, (int)height / 4, (int)width / 4, (int)width / 4, red);\n    gdImageEllipse(img, (int)width * 3 / 4, (int)height * 3 / 4, (int)width / 4, (int)width / 4, red);\n    gdImageLine(img, (int)width / 2, (int)height / 2, (int)width / 2, (int)height / 2 + 100, blue);\n\n    gdPoint points[4] = {\n        { (int)width / 4, (int)height * 3 / 4 },\n        { (int)width / 4 + 100, (int)height * 3 / 4 },\n        { (int)width / 4 + 100, (int)height * 3 / 4 + 100 },\n        { (int)width / 4, (int)height * 3 / 4 + 100 }\n    };\n\n    // Call the rotation function for the first polygon\n    rotateFilledPolygon((int)width / 4 + 50, (int)height * 3 / 4 + 50, 45.0, points, 4);\n    gdImagePolygon(img, points, 4, black);\n\n    gdPoint points2[4] = {\n        { (int)width / 3, (int)height / 2 },\n        { (int)width / 3 + 100, (int)height / 2 },\n        { (int)width / 3 + 100, (int)height / 2 + 100 },\n        { (int)width / 3 - 50, (int)height / 2 + 100 }\n    };\n\n    // Call the rotation function for the second polygon\n    rotateFilledPolygon((int)width / 3 + 50, (int)height / 2 + 50, 30.0, points2, 4);\n    gdImageFilledPolygon(img, points2, 4, red);\n\n    // Save the image to the output file\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n\n    // Free the memory used by the image\n    gdImageDestroy(img);\n\n    return 0;\n}\n \n \n 先設定hello.c的檔 \n #include <stdio.h> \n \nint main() \n{ \nprintf("你好世界\\n"); \n} \n \n 然後再shell打cc hello.c會出現這個 \n \n 然後要回車這樣replit就會幫我準備好c \n 之後再進行一次程式 cc hello.c，然後打./a.out \n 然後就會出現hello world \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\n// Declare the rotation function\nvoid rotateFilledPolygon(int x_orig, int y_orig, double rotation_ang, gdPoint *points, int num_points) {\n    int i;\n    double angle_rad = rotation_ang * M_PI / 180.0;\n\n    for (i = 0; i < num_points; i++) {\n        int x = points[i].x - x_orig;\n        int y = points[i].y - y_orig;\n\n        points[i].x = x_orig + (int)(x * cos(angle_rad) - y * sin(angle_rad));\n        points[i].y = y_orig + (int)(x * sin(angle_rad) + y * cos(angle_rad));\n    }\n}\n\nint main() {\n    int width = 800;\n    int height = 600;\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    FILE *outputFile = fopen("hellogd2.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n\n    int red = gdImageColorAllocate(img, 255, 0, 0);\n    int blue = gdImageColorAllocate(img, 0, 0, 255);\n    int black = gdImageColorAllocate(img, 0, 0, 0);\n    int white = gdImageColorAllocate(img, 255, 255, 255);\n\n    gdImageFilledRectangle(img, 0, 0, width, height, white);\n    gdImageFilledRectangle(img, 0, 0, (int)width / 4, (int)height / 4, blue);\n\n    gdImageFilledEllipse(img, (int)width * 3 / 4, (int)height / 4, (int)width / 4, (int)width / 4, red);\n    gdImageEllipse(img, (int)width * 3 / 4, (int)height * 3 / 4, (int)width / 4, (int)width / 4, red);\n    gdImageLine(img, (int)width / 2, (int)height / 2, (int)width / 2, (int)height / 2 + 100, blue);\n\n    gdPoint points[4];\n    points[0].x = (int)width / 4;\n    points[0].y = (int)height * 3 / 4;\n    points[1].x = points[0].x + 100;\n    points[1].y = points[0].y;\n    points[2].x = points[1].x;\n    points[2].y = points[1].y + 100;\n    points[3].x = points[2].x - 100;\n    points[3].y = points[2].y;\n\n    // Call the rotation function multiple times\n    for (int i = 0; i < 4; i++) {\n        rotateFilledPolygon((int)width / 4 + 50, (int)height * 3 / 4 + 50, 30.0, points, 4);\n        gdImagePolygon(img, points, 4, black);\n    }\n\n    gdPoint points2[4];\n    points2[0].x = (int)width / 3;\n    points2[0].y = (int)height / 2;\n    points2[1].x = points2[0].x + 100;\n    points2[1].y = points2[0].y;\n    points2[2].x = points2[1].x;\n    points2[2].y = points2[1].y + 100;\n    points2[3].x = points2[2].x - 150;\n    points2[3].y = points2[2].y;\n\n    // Call the rotation function multiple times\n    for (int i = 0; i < 12; i++) {\n        //rotateFilledPolygon((int)width / 3 + 50, (int)height / 2 + 50, 30.0, points2, 4);\n        rotateFilledPolygon(500, 200, 30.0, points2, 4);\n        gdImageFilledPolygon(img, points2, 4, red);\n    }\n\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n\n    return 0;\n} \n \n', 'tags': '', 'url': 'W11-12.html'}, {'title': 'w13', 'text': '\n #include <stdio.h>\n\xa0\nint main() {\n// 開啟文件以寫入位移和速度數據\nFILE *outputFile = fopen("motion_data.txt", "w");\nif (!outputFile) {\nfprintf(stderr, "無法創建數據文件。\\n");\nreturn 1;\n}\n\xa0\n// 模擬運動 10 秒並計算位移和速度，同時將數據寫入文件\ndouble x = 0.2; // 初始位移\ndouble v = 0.0; // 初始速度\ndouble dt = 0.01; // 時間步長\ndouble t = 0.0; // 時間\n\xa0\nwhile (t <= 10.0) {\ndouble acceleration = (-10.0 * x - 0.5 * v) / 1.0; // 這裡修改了系統的參數\nv += acceleration * dt;\nx += v * dt;\n\xa0\nfprintf(outputFile, "%lf %lf %lf\\n", t, x, v);\n\xa0\nt += dt;\n}\n\xa0\n// 關閉數據文件\nfclose(outputFile);\n\xa0\n// 使用popen啟動Gnuplot進程\nFILE *gnuplotPipe = popen("gnuplot -persistent", "w");\nif (!gnuplotPipe) {\nfprintf(stderr, "無法啟動Gnuplot。\\n");\nreturn 1;\n}\n\xa0\n// 使用Gnuplot繪圖指令，指定字型文件和輸出PNG\nfprintf(gnuplotPipe, "set terminal png font \'default,12\' size 800,400\\n");\nfprintf(gnuplotPipe, "set output \'./../images/motion_plot.png\'\\n");\nfprintf(gnuplotPipe, "set title \'displacement and velocity vs. time\'\\n");\nfprintf(gnuplotPipe, "set xlabel \'time (s)\'\\n");\nfprintf(gnuplotPipe, "set ylabel \'displacement (m)\'\\n");\nfprintf(gnuplotPipe, "plot \'motion_data.txt\' using 1:2 with lines lw 2 title \'displacement\', \\\n\'motion_data.txt\' using 1:3 with lines lw 2 title \'velocity\'\\n");\n\xa0\n// 關閉Gnuplot進程\nfprintf(gnuplotPipe, "exit\\n");\npclose(gnuplotPipe);\n\xa0\nreturn 0;\n} \n \n \n', 'tags': '', 'url': 'w13.html'}, {'title': 'W15', 'text': '\n \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\n// 定義座標結構\ntypedef struct {\n    double x;\n    double y;\n} Point;\n\nvoid draw_roc_flag(gdImagePtr img);\nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int color);\n\n// 計算圓與線的交點\nvoid circleLineIntersection(double h, double k, double r, double x1, double y1, double x2, double y2);\n\nint main() {\n    // 設定圖片寬度和高度\n    int width = 1200;\n    int height = (int)(width * 2.0 / 3.0);\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    draw_roc_flag(img);\n\n    FILE *outputFile = fopen("roc_flag_in_gd.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n\nvoid draw_roc_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white, blue;\n    int center_x = (int)(width / 4);\n    int center_y = (int)(height / 4);\n    int sun_radius = (int)(width / 8);\n    int white_circle_dia = sun_radius;\n    int blue_circle_dia = white_circle_dia + white_circle_dia * 2 / 15;\n    red = gdImageColorAllocate(img, 255, 0, 0);\n    white = gdImageColorAllocate(img, 255, 255, 255);\n    blue = gdImageColorAllocate(img, 0, 0, 149);\n\n    gdImageFilledRectangle(img, 0, 0, width, height, red);\n    gdImageFilledRectangle(img, 0, 0, (int)(width / 2.0), (int)(height / 2.0), blue);\n\n    draw_white_sun(img, center_x, center_y, sun_radius, white);\n\n    gdImageFilledEllipse(img, center_x, center_y, blue_circle_dia, blue_circle_dia, blue);\n    gdImageFilledEllipse(img, center_x, center_y, white_circle_dia, white_circle_dia, white);\n\n    // 連接第二組ABED的白線\n    int ax = 429;\n    int ay = 125;\n    int bx = 279;\n    int by = 165;\n    int ex = 170;\n    int ey = 274;\n    int dx = 170;\n    int dy = 274;\n\n    // 設定線條寬度\n    gdImageSetThickness(img, 3);\n\n    gdImageLine(img, ax, ay, bx, by, white);\n    gdImageLine(img, bx, by, ex, ey, white);\n    gdImageLine(img, ex, ey, dx, dy, white);\n    gdImageLine(img, dx, dy, ax, ay, white);\n\n    // 新增連線 (ax, ay) 到 (dx, dy)\n    gdImageLine(img, ax, ay, dx, dy, white);\n\n    // 恢復預設線條寬度\n    gdImageSetThickness(img, 1);\n\n    // 利用一個藍色大圓與白色小圓畫出藍色環狀\n    gdImageFilledEllipse(img, center_x, center_y, blue_circle_dia, blue_circle_dia, blue);\n    gdImageFilledEllipse(img, center_x, center_y, white_circle_dia, white_circle_dia, white);\n\n    // 圓的參數\n    double circle_x = (int)(width / 4); // 圓心 x 座標\n    double circle_y = (int)(height / 4); // 圓心 y 座標\n    double radius = white_circle_dia + white_circle_dia * 2 / 15; // 圓半徑\n\n    // 兩點座標\n    double x3 = 170;\n    double y3 = 274;\n    double x4 = 279;\n    double y4 = 165;\n\n    // 計算圓與線段 (x3, y3) 到 (x4, y4) 的交點\n    circleLineIntersection(circle_x, circle_y, radius, x4, y4, x3, y3);\n\n    double x5 = 279;\n    double y5 = 165;\n    double x6 = 429;\n    double y6 = 125;\n\n    // 計算圓與線段 (x6, y6) 到 (x5, y5) 的交點\n    circleLineIntersection(circle_x, circle_y, radius, x6, y6, x5, y5);\n}\n\nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int color) {\n    float deg = M_PI / 180;\n    float sr = sun_radius / tan(75 * deg);\n    int ax, ay, bx, by, dx, dy, ex, ey;\n    gdPoint points[4];\n\n    ax = center_x;\n    ay = center_y - sun_radius;\n    bx = center_x - sun_radius * tan(15 * deg);\n    by = center_y;\n    ex = center_x;\n    ey = center_y + sun_radius;\n    dx = center_x + sun_radius * tan(15 * deg);\n    dy = center_y;\n\n    for (int i = 1; i <= 6; i++) {\n        points[0].x = ax + sun_radius * sin(30 * deg * i);\n        points[0].y = ay + sun_radius - sun_radius * cos(30 * deg * i);\n\n        points[1].x = bx + sr - sr * cos(30 * deg * i);\n        points[1].y = by - sr * sin(30 * deg * i);\n\n        points[2].x = ex - sun_radius * sin(30 * deg * i);\n        points[2].y = ey - (sun_radius - sun_radius * cos(30 * deg * i));\n\n        points[3].x = dx - (sr - sr * cos(30 * deg * i));\n        points[3].y = dy + sr * sin(30 * deg * i);\n\n        gdImageFilledPolygon(img, points, 4, color);\n        gdImagePolygon(img, points, 4, color);\n    }\n}\n\nvoid circleLineIntersection(double h, double k, double r, double x1, double y1, double x2, double y2) {\n    double m = (y2 - y1) / (x2 - x1);\n    double b = y1 - m * x1;\n    double A = 1 + pow(m, 2);\n    double B = 2 * (m * b - m * k - h);\n    double C = pow(k, 2) - pow(r, 2) + pow(h, 2) - 2 * b * k + pow(b, 2);\n\n    double discriminant = pow(B, 2) - 4 * A * C;\n    if (discriminant > 0) {\n        double x_intersect1 = (-B + sqrt(discriminant)) / (2 * A);\n        double y_intersect1 = m * x_intersect1 + b;\n        printf("交點: (%.2f, %.2f)\\n", x_intersect1, y_intersect1);\n\n        double x_intersect2 = (-B - sqrt(discriminant)) / (2 * A);\n        double y_intersect2 = m * x_intersect2 + b;\n        printf("交點: (%.2f, %.2f)\\n", x_intersect2, y_intersect2);\n    } else if (discriminant == 0) {\n        double x_intersect = -B / (2 * A);\n        double y_intersect = m * x_intersect + b;\n        printf("交點: (%.2f, %.2f)\\n", x_intersect, y_intersect);\n    } else {\n        printf("No points.\\n");\n    }\n}\n \n', 'tags': '', 'url': 'W15.html'}, {'title': 'cEX', 'text': '\n \n \n 1. \n #include <stdio.h>\n\nint main()\n{\nfloat a = 0.5;\ndouble b = 1.2;\nint c = 3;\nb = b + a + c;\n\n/* 输出 a, b, c 到屏幕 */\nprintf("a = %3.1f, b = %3.1f, c = %d\\n", a, b, c);\n\nreturn 0;\n} \n \n 2. \n /* ====================\n   字元範例 1\n   ==================== */\n#include <stdio.h>\n\nint main()\n{\n    char x, y;\n\n    x = \'a\';\n    y = (char)97;\n\n    /* 輸出 x, y, x, 最後一個是以 ASCII 值顯示 y */\n    printf("x = %c, y = %c, ASCII of y = %d", x, y, y);\n\n    return 0;\n}\n \n \n 3. \n #include <stdio.h>\n\nint main()\n{\n    int a = 64;\n    int b = 0x40; // 以十六进制表示\n    long c = 64L;\n\n    // 打印变量的值\n    printf("%d, %d, %ld", a, b, c);\n\n    return 0;\n}\n \n \n 4. \n #include <stdio.h>\n\nint main()\n{\n    int a = 10, b = 5;\n\n    // 第一组比较\n    printf("a == b is %d\\n", a == b);\n    printf("a > b is %d\\n", a > b);\n    printf("a < b is %d\\n", a < b);\n    printf("a >= b is %d\\n", a >= b);\n    printf("a <= b is %d\\n", a <= b);\n    printf("a != b is %d\\n", a != b);\n\n    printf("\\n");\n\n    // 修改 b 的值\n    b = 10;\n\n    // 第二组比较\n    printf("a == b is %d\\n", a == b);\n    printf("a > b is %d\\n", a > b);\n    printf("a < b is %d\\n", a < b);\n    printf("a >= b is %d\\n", a >= b);\n    printf("a <= b is %d\\n", a <= b);\n    printf("a != b is %d\\n", a != b);\n\n    return 0;\n}\n \n \n 5. \n #include <stdio.h>\n\nvoid main()\n{\nint a;\n\n// 第一次输出\na = 3;\nprintf("%d\\n", !a); // 逻辑非运算，a为真，所以输出0\n\n// 第二次输出\na = 0;\nprintf("%d\\n", !a); // 逻辑非运算，a为假，所以输出1\n}\n\n \n \n 6. \n #include <stdio.h>\n\nvoid main()\n{\n    char a;\n\n    // 使用 %zu 格式说明符输出 size_t 类型\n    printf("The size of int is %zu\\n", sizeof(int));\n\n    // 使用 %zu 格式说明符输出 size_t 类型\n    printf("The size of char a is %zu\\n", sizeof(a));\n}\n \n \n 7. \n #include <stdio.h>\n\n/* ====================\n计算长方形面积, 需传入长与宽.\n==================== */\nint rect(int x, int y)\n{\n    int result;\n    result = x * y;\n    return result; /* 返回 result */\n}\n\n/* ====================\n主函数\n==================== */\nint main()\n{\n    int x = 8, y = 4;\n    int a;\n    a = rect(x, y);\n    printf("8*4 的面积是 %d", a);\n    return 0;\n}\n \n \n 8. \n #include <stdio.h>\nfloat circle( int r ); /* 宣告 circle 的 prototype */\nvoid main()\n{\nfloat answer;\nanswer = circle(8);\nprintf( " 圓周長度是 %f", answer );\n}\n/* ====================\n circle 函數, 計算 circle 的圓周長\n==================== */\nfloat circle( int r )\n{\nfloat result;\nresult = 3.14159 * (double)1001 * r;\nreturn ( result );\n}\n \n \n 9, \n #include <stdio.h>\n\nint main()\n{\n    char ch;\n\n    printf("输入一个字符：");\n\n    // 检查 scanf 的返回值，确保成功读取一个字符\n    if (scanf(" %c", &ch) != 1) {\n        printf("读取字符失败\\n");\n        return 1; // 或者采取其他错误处理措施\n    }\n\n    if (ch == \'a\') {\n        printf("您按下了 \'a\'\\n");\n    }\n\n    return 0;\n}\n \n \n 10. \n #include <stdio.h>\n\nvoid main()\n{\n    int i;\n\n    // 提示用户输入一个整数\n    printf("100：");\n\n    // 读取用户输入的整数\n    scanf("%d", &i);\n\n    // 判断输入的整数，并输出相应的消息\n    if (i < 100)\n    {\n        printf("i < 100\\n");\n    }\n    else\n    {\n        if ((i >= 100) && (i < 200))\n        {\n            printf("i >= 100 且 i < 200\\n");\n        }\n        else\n        {\n            printf("i >= 200\\n");\n        }\n    }\n}\n \n \n 1.1 \n /* =========================\n function pointer 2\n========================= */\n#include <stdio.h>\n/* ====================\nsay “Hello”.\n==================== */\nvoid Hello(void)\n{\nprintf(“ Hello\\n”);\n}\n/* ====================\nsay “World”.\n==================== */\nvoid World(void)\n{\nprintf(“ World\\n”);\n}\n/* ====================\nmain function.\n==================== */\nint main()\n{\nvoid (*func[3])(void); /* 宣告一個 function pointer array */\nint i = 0 ;\nfunc[0] = Hello; /* 建立 Jumping table */\nfunc[1] = World;\nwhile(1)\n{\nprintf(“Input a number between 0 and 1 : ”);\nscanf( “%d”,&i );\n/* 若 I 大於等於 2 或是小於 0 則離開 loop */\nif( (i >= 2)||(i < 0) )\nbreak;\nelse\nfunc[ i ]( ); /* 執行! */\n}\nreturn 0;\n} \n \n \n \n 1.2 \n   #include <stdio.h>\n\n  /* ====================\n  say “Hello”.\n  ==================== */\n  void Hello(void)\n  {\n      printf("Hello\\n");\n  }\n\n  /* ====================\n  say “World”.\n  ==================== */\n  void World(void)\n  {\n      printf("World\\n");\n  }\n\n  /* ====================\n  main function.\n  ==================== */\n  int main()\n  {\n      void (*func[3])(void); /* 声明一个函数指针数组 */\n      int i = 0;\n\n      func[0] = Hello; /* 建立 Jumping table */\n      func[1] = World;\n\n      while (1)\n      {\n          printf("Input a number between 0 and 1: ");\n          scanf("%d", &i);\n\n          /* 如果 i 大于等于 2 或小于 0 则退出循环 */\n          if (i >= 2 || i < 0)\n              break;\n          else\n              func[i](); /* 执行函数 */\n      }\n\n      return 0;\n  }\n \n \n 1.3 \n #include <stdio.h>\n\n/* ====================\nsay “Hello”.\n==================== */\nvoid Hello(void)\n{\n    printf("Hello\\n");\n}\n\n/* ====================\nsay “World”.\n==================== */\nvoid World(void)\n{\n    printf("World\\n");\n}\n\n/* ====================\nmain function.\n==================== */\nint main()\n{\n    void (*func[3])(void); /* 声明一个函数指针数组 */\n    int i = 0;\n\n    func[0] = Hello; /* 建立 Jumping table */\n    func[1] = World;\n\n    while (1)\n    {\n        printf("Input a number between 0 and 1: ");\n\n        // 检查 scanf 的返回值，确保成功读取一个整数\n        if (scanf("%d", &i) != 1)\n        {\n            printf("无效输入，请输入一个整数。\\n");\n            break;\n        }\n\n        /* 如果 i 大于等于 2 或小于 0 则退出循环 */\n        if (i >= 2 || i < 0)\n            break;\n        else\n            func[i](); /* 执行函数 */\n    }\n\n    return 0;\n}  \n \n 2.1 \n /* ====================\n pointer to pointer – 1.\n==================== */\n#include <stdio.h>\nint main()\n{\nchar *Hello = “Hello”;\nchar *World = “World”;\nchar *GoodBye = “Good Bye”;\nchar *StrArray[3];\nchar **Str;\nint i;\nStr = StrArray;\nStrArray[0] = Hello;\nStrArray[1] = World;\nStrArray[2] = GoodBye;\nfor( i = 0; i < 3; i++ )\n{\nprintf(“%s”, StrArray[ i ] );\n}\nfor( i = 0; i < 3; i++ )\n{\nprintf(“%s”, *Str );\nStr++;\n}\nretur \n 2.2 \n /* ====================\n pointer to pointer – 1.\n==================== */\n#include <stdio.h>\n\nint main() {\n    char *Hello = "Hello";\n    char *World = "World";\n    char *GoodBye = "Good Bye";\n    char *StrArray[3];\n    char **Str;\n    int i;\n\n    Str = StrArray;\n    StrArray[0] = Hello;\n    StrArray[1] = World;\n    StrArray[2] = GoodBye;\n\n    // Print strings using array indexing\n    for (i = 0; i < 3; i++) {\n        printf("%s ", StrArray[i]);\n    }\n\n    // Print strings using pointer arithmetic\n    Str = StrArray;  // Reset the pointer to the beginning\n    for (i = 0; i < 3; i++) {\n        printf("%s ", *Str);\n        Str++;\n    }\n\n    return 0;\n}\n \n \xa0 \n 我的圖片不知道為甚麼不能傳所以我用打字說明 \n 先打cc ex.2-1.c再來打./a.out\xa0Hello World Good Bye Hello World Good Bye\n\n#include <stdio.h>\n\nint main() {\nprintf("int 类型的大小为 %zu 字节\\n", sizeof(int));\n\nchar a;\nprintf("char 类型变量 a 的大小为 %zu 字节\\n", sizeof(a));\n\nreturn 0;\n} \n \n #include <stdio.h>\n\nint main() {\nfloat this_is_a_number1, this_is_a_number2;\nint scanf_result; // Dummy variable to capture scanf\'s return value\n\n/* 读取输入的浮点数 */\nscanf_result = scanf("%f", &this_is_a_number1);\n\n/* 读取输入的浮点数 */\nscanf_result = scanf("%f", &this_is_a_number2);\n\n/* Your code here */\n\nreturn 0;\n}\n\n \n 布萊頓 \n https://en.wikipedia.org/wiki/Python_（程式語言） \n 例子： \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python教學： \n https://docs.python.org/3/tutorial/ \n Python的平衡介紹 \n 縮排（Python採用4個Spaces縮排，以介面執行範圍） \n 變數（ Python 關鍵字 ） \n 註（#單行註解、三單標註或三雙標註標註多行註解） \n 數 (整數 int(), 浮點數 float()) \n 字串 （字符串） \n print (Python 內建函數,  print() 函數式) \n Python是控制流程工具 \n 為了 \n 如果 \n 範圍 \n 開放 \n 讀 \n 清單 \n 元組 \n 字典 \n 功能 \n 嘗試...除了 \n 休息時間 \n 曾經 \n 類別 \n 此頁面示範如何在同一頁面下加入多個線上Ace編輯器與執行按鈕（ practice_html.txt 動態頁面超檔案）。 \n Practice_html.txt 動態頁面超檔案應該可以在啟動Brython時，設定分割.py檔案放入downloads/py目錄中的參考。 \n 也所有出現的反html也使用Brython產生，編寫成 類別 後，在範例匯入時交叉< ai=3>實例 引用。 \n \n<腳本> \n視窗.onload=函數(){ \nbrython({ 調試:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']}); \n} \n</> 腳本 \n 從1累加到100： \n 1加到100 \n 將iterable與iterator 相關說明 ，利用Brython與Ace Editor整理頁面。 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n 文件名稱： .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n 跑步   輸出   明確輸出區 清晰的繪圖區 重新載入 \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從1累加到100第2部分： \n 1加到100 cango_三_齒輪 BS蛇 人工智慧俄羅斯區塊鏈 旋轉塊 \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n 文件名稱： .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n 跑步   輸出   明確輸出區 清晰的繪圖區 重新載入 \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n', 'tags': '', 'url': 'cEX.html'}]};