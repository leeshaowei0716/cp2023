var tipuesearch = {"pages": [{'title': '關於', 'text': 'https://github.com/mdecycu/cmsite \n', 'tags': '', 'url': '關於.html'}, {'title': 'w2-3', 'text': '網路設定 \n \n \n', 'tags': '', 'url': 'w2-3.html'}, {'title': 'w4-5', 'text': '// 包含標準輸出入程式庫的標頭文件\n// https://blog.csdn.net/weixin_38468077/article/details/101069365\n// http://www.gnuplot.info/demo/\n// https://github.com/sysprog21/rv32emu\n// https://github.com/sysprog21/semu \n// https://docs.google.com/presentation/d/14N0cWG2SnBSqhc2cLF0_2VerB9FF8JN3\n// https://cs61c.org/fa23/\n// https://greenteapress.com/wp/think-python-2e/\n// https://github.com/ecalvadi/c99-examples\n// https://github.com/gouravthakur39/beginners-C-program-examples\n// https://github.com/ergenekonyigit/Numerical-Analysis-Examples\n// https://www.che.ncku.edu.tw/facultyweb/changct/html/teaching/CPPandMATLAB/Past/pdf%20Files/Chap02-Ling.pdf\n// https://gteceducation.com.sg/Brochures/PROGRAMMING/C%20PROGRAMMING%20FULL.pdf\n// https://jsommers.github.io/cbook/cbook.pdf\n// https://jsommers.github.io/cbook/index.html\n// http://student.itee.uq.edu.au/courses/csse2310/CProgrammingNotes.pdf\n// http://cslibrary.stanford.edu/101/EssentialC.pdf\n// https://publications.gbdirect.co.uk/c_book/\n// https://www.fossil-scm.org/fossil-book/doc/2ndEdition/fossilbook.pdf\n// ***** execute on replit \n// cd downloads\n// cc gnuplot_ex1.c -o gnuplot_ex1\n// ./gnuplot_ex1\n#include <stdio.h>\n\n// 主函式\nint main() {\n    // Start a Gnuplot process using popen\n    FILE *gnuplotPipe = popen("gnuplot -persistent", "w");\n    if (!gnuplotPipe) {\n        fprintf(stderr, "Failed to start Gnuplot.\\n");\n        return 1;\n    }\n\n    // Use Gnuplot plotting commands, specify font and output as PNG\n    fprintf(gnuplotPipe, "set terminal png font \'default,10\' size 800,400\\n");\n    fprintf(gnuplotPipe, "set output \'./../images/gnuplot_ex1.png\'\\n");\n    fprintf(gnuplotPipe, "plot sin(x)");\n    // Close popen\n    pclose(gnuplotPipe);\n\n    return 0;\n} \n \xa0 \n', 'tags': '', 'url': 'w4-5.html'}, {'title': 'w6', 'text': '未完成的台灣國旗 \n // https://en.wikipedia.org/wiki/Flag_of_the_Republic_of_China\n// cc roc_flag.c -lgd -lm to link with gd and math library\n// https://www.rapidtables.com/web/color/RGB_Color.html\n// 幾何形狀著色與繪圖練習\n// 以下 gd 繪圖程式嘗試畫出 ROC 國旗, 請根據下列程式內容完成後續的國旗繪圖\n#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n  \nvoid draw_roc_flag(gdImagePtr img);\nvoid draw_white_sun(gdImagePtr img, int x, int y, int size, int color);\n  \nint main() {\n    // width 3: height 2\n    int width = 1200;\n    int height = (int)(width*2.0 / 3.0);\n  \n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n  \n    draw_roc_flag(img);\n  \n    FILE *outputFile = fopen("./../images/roc_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n  \nvoid draw_roc_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white, blue;\n    int center_x = (int)(width/4);\n    int center_y = (int)(height/4);\n    int sun_radius = (int)(width/8);\n    // Colors for the flag\n    red = gdImageColorAllocate(img, 242, 0, 0); // Red color\n    white = gdImageColorAllocate(img, 255, 255, 255); // White stripes\n    blue = gdImageColorAllocate(img, 0, 41, 204); // Blue\n    // red rectangle area\n    gdImageFilledRectangle(img, 0, 0, width, height, red);\n    // blue rectangle area\n    gdImageFilledRectangle(img, 0, 0, (int)(width/2.0), (int)(height/2.0), blue);\n    // 目前僅畫出青天白日的輪廓直線, 請嘗試計算所需的點座標完成國旗繪圖\n    draw_white_sun(img, center_x, center_y, sun_radius, white);\n}\n  \nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int color) {\n    float angle = 0;\n    int fromX, fromY;\n    int toX, toY;\n    for (int i=0; i<24; i++){\n        angle += 5*M_PI*2/12;\n        //printf("%.3f", angle);\n        toX = center_x + cos(angle)*sun_radius;\n        toY = center_y + sin(angle)*sun_radius;\n        // 只有 i 為 0 時移動到 toX, toY, 其餘都進行直線繪圖\n        if (i!=0){\n            gdImageLine(img, fromX, fromY, toX, toY, color);\n        }\n        fromX = toX;\n        fromY = toY;\n   }\n} \n \n // https://en.wikipedia.org/wiki/Flag_of_the_United_States\n// https://www.britannica.com/topic/flag-of-the-United-States-of-America\n// 以下為幾乎要繪製完成的美國國旗, 請修改下列原始碼, 令其繪出正確的美國國旗\n#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n  \nvoid draw_usa_flag(gdImagePtr img);\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color);\n  \nint main() {\n    int width = 800;\n    int height = (int)(width / 1.9);\n  \n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n  \n    draw_usa_flag(img);\n  \n    FILE *outputFile = fopen("./../images/usa_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n  \n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n  \n    return 0;\n}\n  \nvoid draw_usa_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white, blue;\n    // Colors for the flag\n    red = gdImageColorAllocate(img, 178, 34, 52); // Red stripes\n    white = gdImageColorAllocate(img, 255, 255, 255); // White stripes\n    blue = gdImageColorAllocate(img, 60, 59, 110); // Blue field\n  \n    int stripe_height = height / 13;\n    int stripe_width = width;\n    int star_size = (int)(0.0308 * height); // Corrected star size (half the original size)\n  \n    for (int y = 0; y < height; y += stripe_height) {\n        if (y / stripe_height % 2 == 0) {\n            gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, red);\n        } else {\n            gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, white);\n        }\n    }\n  \n    gdImageFilledRectangle(img, 0, 0, width * 2 / 5, stripe_height * 7, blue);\n  \n    int star_spacing_x = (int)(0.063 * height); // Horizontal spacing between stars\n    int star_spacing_y = (int)(0.054 * height); // Vertical spacing between stars\n    int star_start_x = (int)(0.0616 * height); // Starting X position for stars\n    int star_start_y = (int)(0.0485 * height); // Starting Y position for stars\n  \n    for (int row = 0; row < 9; row++) {\n        int starsPerRow = (row % 2 == 0) ? 6 : 5;\n  \n        for (int star = 0; star < starsPerRow; star++) {\n            int x = star_start_x + star * star_spacing_x;\n            int y = star_start_y + row * star_spacing_y;\n            draw_star(img, x, y, star_size, white);\n        }\n    }\n}\n  \nvoid draw_star(gdImagePtr img, int x, int y, int size, int color) {\n    gdPoint points[10];\n  \n    for (int i = 0; i < 10; i++) {\n        double angle = M_PI / 2 + i * 2 * M_PI / 10;\n        int radius = (i % 2 == 0) ? size : size / 2;\n        points[i].x = x + radius * cos(angle);\n        points[i].y = y + radius * sin(angle);\n    }\n  \n    // Fill the star with white color\n    gdImageFilledPolygon(img, points, 10, color);\n} \n \n', 'tags': '', 'url': 'w6.html'}, {'title': 'w7', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n \nvoid draw_roc_flag(gdImagePtr img);\nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int white, int red, int blue);\n \nint main() {\n    // width 3: height 2\n    int width = 1200;\n    int height = (int)(width*2.0 / 3.0);\n \n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n \n    draw_roc_flag(img);\n \n    FILE *outputFile = fopen("./roc_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n \nvoid draw_roc_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white, blue;\n    int center_x = (int)(width/4);\n    int center_y = (int)(height/4);\n    int sun_radius = (int)(width/8);\n \n    // Colors for the flag\n    red = gdImageColorAllocate(img, 242, 0, 0); // Red color\n    white = gdImageColorAllocate(img, 255, 255, 255); // White stripes\n    blue = gdImageColorAllocate(img, 0, 41, 204); // Blue\n \n    // 繪製紅色矩形區域\n    gdImageFilledRectangle(img, 0, 0, width, height, red);\n \n    // 繪製藍色矩形區域\n    gdImageFilledRectangle(img, 0, 0, (int)(width/2.0), (int)(height/2.0), blue);\n \n    // 繪製太陽\n    draw_white_sun(img, center_x, center_y, sun_radius, white, red, blue);\n}\nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int white, int red, int blue) {\n    float angle = 0;\n    int numRays = 12; // 光芒的數量\n \n    gdPoint points[3]; // 三個頂點的陣列\n \n    for (int i = 0; i < numRays; i++) {\n        angle = i * (2 * M_PI / numRays);\n        float x1 = center_x + cos(angle) * sun_radius;\n        float y1 = center_y + sin(angle) * sun_radius;\n \n        // 調整兩個底邊頂點的位置\n      float x2 = center_x + cos(angle + 0.35) * (sun_radius * 0.5);\n      float y2 = center_y + sin(angle + 0.35) * (sun_radius * 0.5);\n      float x3 = center_x + cos(angle - 0.35) * (sun_radius * 0.5);\n      float y3 = center_y + sin(angle - 0.35) * (sun_radius * 0.5);\n \n        // 設定多邊形的三個頂點\n        points[0].x = (int)x1;\n        points[0].y = (int)y1;\n        points[1].x = (int)x2;\n        points[1].y = (int)y2;\n        points[2].x = (int)x3;\n        points[2].y = (int)y3;\n \n        gdImageFilledPolygon(img, points, 3, white);\n    }\n  //外圈\n  gdImageFilledEllipse(img, center_x, center_y, sun_radius * 1.2, sun_radius * 1.2, blue);\n   \n    // 繪製太陽內部\n    gdImageFilledEllipse(img, center_x, center_y, sun_radius * 1.1, sun_radius * 1.1, white);\n} \n \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nvoid draw_usa_flag(gdImagePtr img);\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle);\n\nint main() {\n    int width = 800;\n    int height = (int)(width / 1.9);\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    draw_usa_flag(img);\n\n    FILE *outputFile = fopen("./../images/usa_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "打开输出文件时出错。\\n");\n        return 1;\n    }\n\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n\n    return 0;\n}\n\nvoid draw_usa_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white, blue;\n    // 国旗颜色\n    red = gdImageColorAllocate(img, 178, 34, 52); // 红色条纹\n    white = gdImageColorAllocate(img, 255, 255, 255); // 白色条纹\n    blue = gdImageColorAllocate(img, 60, 59, 110); // 蓝色矩形\n\n    int stripe_height = height / 13;\n    int stripe_width = width;\n    int star_size = (int)(0.0308 * height); // 星星大小\n\n    for (int y = 0; y < height; y += stripe_height) {\n        if (y / stripe_height % 2 == 0) {\n            gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, red);\n        } else {\n            gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, white);\n        }\n    }\n\n    gdImageFilledRectangle(img, 0, 0, width * 2 / 5, stripe_height * 7, blue);\n\n    int star_spacing_x = (int)(0.129 * height); // 横向星星之间的间距\n    int star_spacing_y = (int)(0.054 * height); // 纵向星星之间的间距\n    int star_start_x = (int)(0.125 * height); // 星星的起始X位置\n    int star_start_y = (int)(0.0485 * height); // 星星的起始Y位置\n\n    for (int row = 0; row < 9; row++) {\n        int starsPerRow = (row % 2 == 0) ? 6 : 5;\n\n        // 计算2、4、6和8排星星的偏移量\n        int offset_x = (row % 2 == 0) ? star_spacing_x / -2 : 0;\n\n        for (int star = 0; star < starsPerRow; star++) {\n            int x = star_start_x + star * star_spacing_x + offset_x;\n\n            // 旋转角度（以弧度为单位）\n            double rotation_angle = M_PI / 5; // 忘記多少度的旋转\n\n            int y = star_start_y + row * star_spacing_y;\n            draw_star(img, x, y, star_size, white, rotation_angle);\n        }\n    }\n}\n\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle) {\n    gdPoint points[10];\n\n    for (int i = 0; i < 10; i++) {\n        double angle = M_PI / 2 + i * 2 * M_PI / 10 + rotation_angle;\n        int radius = (i % 2 == 0) ? size : size / 2;\n        points[i].x = x + radius * cos(angle);\n        points[i].y = y + radius * sin(angle);\n    }\n\n    // 用指定的颜色填充星星\n    gdImageFilledPolygon(img, points, 10, color);\n} \n \n \n', 'tags': '', 'url': 'w7.html'}, {'title': 'w8', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <stdlib.h>\n\nvoid drawJapaneseFlag() {\n    int width = 300;   // 寬度\n    int height = 200;  // 高度\n    int radius = 50;   // 圓圈半徑\n    int centerX = 150; // 圓圈中心X座標\n    int centerY = 100; // 圓圈中心Y座標\n\n    // 創建一個 24 位的彩色圖片\n    gdImagePtr im = gdImageCreateTrueColor(width, height);\n\n    // 設置背景色為白色\n    int white = gdImageColorAllocate(im, 255, 255, 255);\n    gdImageFill(im, 0, 0, white);\n\n    // 設置圓圈的顏色為紅色\n    int red = gdImageColorAllocate(im, 255, 0, 0);\n\n    // 畫紅色圓圈\n    gdImageFilledEllipse(im, centerX, centerY, 2 * radius, 2 * radius, red);\n\n    // 輸出圖片到檔案\n    FILE *output = fopen("japanese_flag.png", "wb");\n    if (output == NULL) {\n        fprintf(stderr, "Unable to open file for writing.\\n");\n        exit(EXIT_FAILURE);\n    }\n\n    gdImagePng(im, output);\n\n    // 釋放內存\n    gdImageDestroy(im);\n    fclose(output);\n}\n\nint main() {\n    drawJapaneseFlag();\n    printf("Japanese flag created: japanese_flag.png\\n");\n    return 0;\n} \n \n \n #include <stdio.h>\n  #include <gd.h>\n  #include <math.h>\n\n  void draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle);\n  void draw_chinese_flag(gdImagePtr img);\n\n  int main() {\n      int width = 300; // 國旗寬度\n      int height = 200; // 國旗高度\n\n      gdImagePtr im = gdImageCreateTrueColor(width, height);\n      gdImageAlphaBlending(im, 0);\n\n      draw_chinese_flag(im);\n\n      FILE *outputFile = fopen("./../images/proc_flag.png", "wb");\n      if (outputFile == NULL) {\n          fprintf(stderr, "打開輸出文件時出錯。\\n");\n          return 1;\n      }\n\n      gdImagePngEx(im, outputFile, 9);\n      fclose(outputFile);\n      gdImageDestroy(im);\n\n      return 0;\n  }\n\n  void draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle) {\n      gdPoint points[10];\n\n      double outer_radius = size / 2;\n      double inner_radius = size / 6;\n      double angle = M_PI / 5.0;\n\n      for (int i = 0; i < 10; i++) {\n          double radius = (i % 2 == 0) ? outer_radius : inner_radius;\n          double theta = rotation_angle + i * angle;\n          points[i].x = x + radius * cos(theta);\n          points[i].y = y + radius * sin(theta);\n      }\n\n      gdImageFilledPolygon(img, points, 10, color);\n  }\n\n  void draw_chinese_flag(gdImagePtr img) {\n      int width = gdImageSX(img);\n      int height = gdImageSY(img);\n      int red, yellow;\n\n      red = gdImageColorAllocate(img, 255, 0, 0); // 紅色背景\n      yellow = gdImageColorAllocate(img, 255, 255, 0); // 黃色星星\n\n      gdImageFilledRectangle(img, 0, 0, width, height, red);\n\n      int star_size = (int)(0.28 * height);\n      int star_x = (int)(0.165 * width);\n      int star_y = (int)(0.265 * height);\n\n      draw_star(img, star_x, star_y, star_size, yellow, 11.0);\n\n      double radius = 0.15 * height;\n      double angle = 360 / 7 * M_PI / 179.0;\n      double rotation = -M_PI / 7.5;\n      int cx = (int)(0.32 * width);\n      int cy = (int)(0.27 * height);\n\n      for (int i = -1; i < 3; i++) {\n          int x = (int)(cx + radius * cos(i * angle + rotation));\n          int y = (int)(cy + radius * sin(i * angle + rotation));\n          draw_star(img, x, y, 19, yellow, M_PI / 5.0);\n      }\n  }\n \n \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nvoid draw_uk_flag(gdImagePtr img);\nvoid fillTriangle(gdImagePtr img, int x1, int y1, int x2, int y2, int x3, int y3, int color);\n\nint main() {\n    int width = 1200;\n    int height = width / 2;\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    draw_uk_flag(img);\n\n    FILE *outputFile = fopen("./../images/uk_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "打開輸出文件時發生錯誤。\\n");\n        return 1;\n    }\n\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n\n    return 0;\n}\n\nvoid draw_uk_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n\n    int red, white, blue;\n    red = gdImageColorAllocate(img, 204, 0, 0);\n    white = gdImageColorAllocate(img, 255, 255, 255);\n    blue = gdImageColorAllocate(img, 0, 0, 153);\n\n    gdImageFilledRectangle(img, 0, 0, width, height, blue);\n\n    // 繪製斜線\n    {\n        int line_thickness = 100;\n        gdImageSetThickness(img, line_thickness);\n\n        // 繪製白色斜線\n        int x1 = 0, y1 = 600, x2 = 1200, y2 = 0;\n        gdImageLine(img, x1, y1, x2, y2, white);\n\n        x1 = 0, y1 = 0, x2 = 1200, y2 = 600;\n        gdImageLine(img, x1, y1, x2, y2, white);\n    }\n\n    // 繪製紅色斜線\n    {\n        int line_thickness = 33;\n        gdImageSetThickness(img, line_thickness);\n\n        // 繪製紅色斜線\n        int x1 = 566, y1 = 300, x2 = 1166, y2 = 0;\n        gdImageLine(img, x1, y1, x2, y2, red);\n\n        x1 = 1233, y1 = 600, x2 = 633, y2 = 300;\n        gdImageLine(img, x1, y1, x2, y2, red);\n\n        x1 = 566, y1 = 300, x2 = -33, y2 = 0;\n        gdImageLine(img, x1, y1, x2, y2, red);\n\n        x1 = 600, y1 = 316.5, x2 = 0, y2 = 616.5;\n        gdImageLine(img, x1, y1, x2, y2, red);\n    }\n\n    // 繪製白色斜線\n    {\n        int line_thickness = 33;\n        gdImageSetThickness(img, line_thickness);\n\n        // 繪製斜線\n        int x1 = 0, y1 = 600, x2 = 1200, y2 = 0;\n        gdImageLine(img, x1, y1, x2, y2, red);\n\n        x1 = 1200, y1 = 16.5, x2 = 600, y2 = 316.5;\n        gdImageLine(img, x1, y1, x2, y2, white);\n\n        x1 = 0, y1 = 583.5, x2 = 600, y2 = 283.5;\n        gdImageLine(img, x1, y1, x2, y2, white);\n    }\n\n    // 繪製白色十字\n    int cross_width = width / 32;\n    int cross_arm_width = width / 32;\n    int center_x = width / 2;\n    int center_y = height / 2;\n\n    gdImageFilledRectangle(img, center_x + 2.7 * cross_width, 0, center_x - 2.7 * cross_width, height, white);\n    gdImageFilledRectangle(img, 0, center_y + 2.7 * cross_arm_width, width, center_y - 2.7 * cross_arm_width, white);\n\n    // 繪製紅色十字\n    gdImageFilledRectangle(img, center_x + 1.5 * cross_width, 0, center_x - 1.5 * cross_width, height, red);\n    gdImageFilledRectangle(img, 0, center_y + 1.5 * cross_arm_width, width, center_y - 1.5 * cross_arm_width, red);\n}\n \n \n #include <stdio.h>\n#include <gd.h>\n\nint main() {\n    // Create a new GD image (French flag dimensions: 900x600)\n    gdImagePtr im = gdImageCreateTrueColor(900, 600);\n\n    // Define colors (RGB format)\n    int blue = gdImageColorAllocate(im, 0, 0, 255);\n    int white = gdImageColorAllocate(im, 255, 255, 255);\n    int red = gdImageColorAllocate(im, 255, 0, 0);\n\n    // Draw vertical stripes (3 equal-width stripes)\n    int stripeWidth = 900 / 3;\n    gdImageFilledRectangle(im, 0, 0, stripeWidth - 1, 599, blue);\n    gdImageFilledRectangle(im, stripeWidth, 0, 2 * stripeWidth - 1, 599, white);\n    gdImageFilledRectangle(im, 2 * stripeWidth, 0, 899, 599, red);\n\n    // Save the image to a file\n    FILE *outputFile = fopen("french_flag.png", "wb");\n    gdImagePng(im, outputFile);\n    fclose(outputFile);\n\n    // Free the GD image\n    gdImageDestroy(im);\n\n    return 0;\n}\n \n \n #include <gd.h>\n#include <stdio.h>\n#include <math.h>\n\nint main() {\n    gdImagePtr im;\n    FILE *output;\n    int white, red, blue, black;\n\n    im = gdImageCreateTrueColor(600, 400);\n    white = gdImageColorAllocate(im, 255, 255, 255);\n    red = gdImageColorAllocate(im, 225, 0, 0);\n    blue = gdImageColorAllocate(im, 0, 0, 225);\n    black = gdImageColorAllocate(im, 0, 0, 0);\n\n    // 填充白色背景\n    gdImageFilledRectangle(im, 0, 0, 599, 399, white);\n\n    // 在中間添加紅藍各一半的圓，將紅色移到上方，藍色移到下方\n    int centerX = 300;\n    int centerY = 200;\n    int radius = 200;\n\n    gdImageFilledArc(im, centerX, centerY, radius, radius, 0, 180, blue, gdPie);\n    gdImageFilledArc(im, centerX, centerY - 1, radius, radius, 180, 360, red, gdPie);\n\n    // 在中間添加向右偏移49的直徑為100的藍色圓\n    int blueCircleRadius = 50; // 半徑為50\n    int offsetX = 49;\n    gdImageFilledEllipse(im, centerX + offsetX, centerY, blueCircleRadius * 2, blueCircleRadius * 2, blue);\n\n    // 在中間添加向左偏移50的直徑為100的紅色圓\n    int redCircleRadius = 50; // 半徑為50\n    gdImageFilledEllipse(im, centerX - 49, centerY, redCircleRadius * 2, redCircleRadius * 2, red);\n\n    // 將中間的圖形順時針旋轉104度\n    double angle = 104.0;\n    gdImagePtr rotated_im = gdImageCreateTrueColor(600, 400);\n    gdImageFilledRectangle(rotated_im, 0, 0, 599, 399, white);\n\n    // 複製原始圖像\n    gdImageCopy(rotated_im, im, 0, 0, 0, 0, 600, 400);\n\n    // 逆時針旋轉的角度\n    double rotationAngle = 25.0; \n\n    // 繪製斜直的長方形\n    int rectWidth = 15;   // 長方形寬度\n    int rectHeight = 120;  // 長方形高度\n    int rectSpacing = 10;  // 長方形間隔\n\n    // 計算三個長方形的左上角座標\n    int rect1X = 139 - rectWidth - rectSpacing;  // 第一個長方形\n    int rect1Y = 206 - rectHeight / 2;\n    int rect2X = rect1X - rectWidth - rectSpacing;  // 第二個長方形\n    int rect2Y = rect1Y;\n    int rect3X = rect2X - rectWidth - rectSpacing;  // 第三個長方形\n    int rect3Y = rect1Y;\n\n    gdPoint points1[4];\n    points1[0].x = (int)(rect1X - centerX) * cos(rotationAngle * M_PI / 180) - (rect1Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points1[0].y = (int)(rect1X - centerX) * sin(rotationAngle * M_PI / 180) + (rect1Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points1[1].x = (int)((rect1X + rectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - (rect1Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points1[1].y = (int)((rect1X + rectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + (rect1Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points1[2].x = (int)((rect1X + rectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect1Y + rectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points1[2].y = (int)((rect1X + rectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect1Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points1[3].x = (int)(rect1X - centerX) * cos(rotationAngle * M_PI / 180) - ((rect1Y + rectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points1[3].y = (int)(rect1X - centerX) * sin(rotationAngle * M_PI / 180) + ((rect1Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n    gdPoint points2[4];\n    points2[0].x = (int)(rect2X - centerX) * cos(rotationAngle * M_PI / 180) - (rect2Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points2[0].y = (int)(rect2X - centerX) * sin(rotationAngle * M_PI / 180) + (rect2Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points2[1].x = (int)((rect2X + rectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - (rect2Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points2[1].y = (int)((rect2X + rectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + (rect2Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points2[2].x = (int)((rect2X + rectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect2Y + rectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points2[2].y = (int)((rect2X + rectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect2Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points2[3].x = (int)(rect2X - centerX) * cos(rotationAngle * M_PI / 180) - ((rect2Y + rectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points2[3].y = (int)(rect2X - centerX) * sin(rotationAngle * M_PI / 180) + ((rect2Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n    gdPoint points3[4];\n    points3[0].x = (int)(rect3X - centerX) * cos(rotationAngle * M_PI / 180) - (rect3Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points3[0].y = (int)(rect3X - centerX) * sin(rotationAngle * M_PI / 180) + (rect3Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points3[1].x = (int)((rect3X + rectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - (rect3Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points3[1].y = (int)((rect3X + rectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + (rect3Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points3[2].x = (int)((rect3X + rectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect3Y + rectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points3[2].y = (int)((rect3X + rectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect3Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n    points3[3].x = (int)(rect3X - centerX) * cos(rotationAngle * M_PI / 180) - ((rect3Y + rectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n    points3[3].y = (int)(rect3X - centerX) * sin(rotationAngle * M_PI / 180) + ((rect3Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n    gdImageFilledPolygon(rotated_im, points1, 4, black);\n    gdImageFilledPolygon(rotated_im, points2, 4, black);\n    gdImageFilledPolygon(rotated_im, points3, 4, black);\n\n\n  {// 添加新的黑色斜形\n  gdPoint rect4Points[4];\n  int rect4X = 70;  // 第四個長方形\n  int rect4Y = 185;\n  rect4Points[0].x = (int)(rect4X - centerX) * cos(rotationAngle * M_PI / 180) + (rect4Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4Points[0].y = (int)(rect4X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  int rect4Width = rectWidth;  // 假設 rectWidth 已經定義\n  int rect4Height = rectHeight;  // 假設 rectHeight 已經定義\n  rect4Points[1].x = (int)((rect4X + rect4Width) - centerX) * cos(rotationAngle * M_PI / 180) + (rect4Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4Points[1].y = (int)((rect4X + rect4Width) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4Points[2].x = (int)((rect4X + rect4Width) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4Y + rect4Height) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4Points[2].y = (int)((rect4X + rect4Width) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4Y + rect4Height) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4Points[3].x = (int)(rect4X - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4Y + rect4Height) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4Points[3].y = (int)(rect4X - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4Y + rect4Height) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect4Points, 4, black);\n\n  // 修改第五個斜形\n  gdPoint rect5Points[4];\n  int rect5X = rect4X + rect4Width + rectSpacing;  // 第五個長方形\n  int rect5Y = rect4Y;\n  int middleRectWidth = 15;    // 中間長方形寬度\n  int middleRectHeight = 55;   // 中間長方形高度\n  int middleRectSpacing = 10;  // 中間長方形上下間隔\n  rect5Points[0].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) + (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[0].y = (int)(rect5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[1].x = (int)((rect5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) + (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[1].y = (int)((rect5X + middleRectWidth) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[2].x = (int)((rect5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[2].y = (int)((rect5X + middleRectWidth) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[3].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) + ((rect5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[3].y = (int)(rect5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect5Points, 4, black);\n\n  // 添加位於第五個斜形下方的新的黑色斜形\n  gdPoint rectBelow5Points[4];\n  int rectBelow5X = rect5X;\n  int rectBelow5Y = rect5Y + middleRectHeight + middleRectSpacing;\n  rectBelow5Points[0].x = (int)(rectBelow5X - centerX) * cos(rotationAngle * M_PI / 180) + (rectBelow5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[0].y = (int)(rectBelow5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rectBelow5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rectBelow5Points[1].x = (int)((rectBelow5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) + (rectBelow5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[1].y = (int)((rectBelow5X + middleRectWidth) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rectBelow5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rectBelow5Points[2].x = (int)((rectBelow5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) + ((rectBelow5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[2].y = (int)((rectBelow5X + middleRectWidth) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rectBelow5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rectBelow5Points[3].x = (int)(rectBelow5X - centerX) * cos(rotationAngle * M_PI / 180) + ((rectBelow5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[3].y = (int)(rectBelow5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rectBelow5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rectBelow5Points, 4, black);\n\n  // 添加新的黑色斜形\n  gdPoint rect6Points[4];\n  int rect6X = rect5X + middleRectWidth + rectSpacing;  // 第六個長方形\n  int rect6Y = rect4Y;\n  rect6Points[0].x = (int)(rect6X - centerX) * cos(rotationAngle * M_PI / 180) + (rect6Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6Points[0].y = (int)(rect6X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  int rect6Width = rectWidth;  // 假設 rectWidth 已經定義\n  int rect6Height = rectHeight;  // 假設 rectHeight 已經定義\n  rect6Points[1].x = (int)((rect6X + rect6Width) - centerX) * cos(rotationAngle * M_PI / 180) + (rect6Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6Points[1].y = (int)((rect6X + rect6Width) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6Points[2].x = (int)((rect6X + rect6Width) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6Y + rect6Height) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6Points[2].y = (int)((rect6X + rect6Width) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6Y + rect6Height) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6Points[3].x = (int)(rect6X - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6Y + rect6Height) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6Points[3].y = (int)(rect6X - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6Y + rect6Height) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect6Points, 4, black);}\n\n  {// 添加新的黑色斜形（第四個，上半部分）\n  gdPoint rect4aPoints[4];\n  int rect4aX = 460;  // 第四個長方形（上半部分）\n  int rect4aY = 139;\n  rect4aPoints[0].x = (int)(rect4aX - centerX) * cos(rotationAngle * M_PI / 180) + (rect4aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[0].y = (int)(rect4aX - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4aPoints[1].x = (int)((rect4aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect4aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[1].y = (int)((rect4aX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4aPoints[2].x = (int)((rect4aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[2].y = (int)((rect4aX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4aPoints[3].x = (int)(rect4aX - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[3].y = (int)(rect4aX - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect4aPoints, 4, black);\n\n  // 添加新的黑色斜形（第四個，下半部分）\n  gdPoint rect4bPoints[4];\n  int rect4bX = 460;  // 第四個長方形（下半部分）\n  int rect4bY = 139 + 55 + 10;  // 上半部分的 Y 座標 + 上半部分的高度 + 間隔\n  rect4bPoints[0].x = (int)(rect4bX - centerX) * cos(rotationAngle * M_PI / 180) + (rect4bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[0].y = (int)(rect4bX - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4bPoints[1].x = (int)((rect4bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect4bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[1].y = (int)((rect4bX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4bPoints[2].x = (int)((rect4bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[2].y = (int)((rect4bX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4bPoints[3].x = (int)(rect4bX - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[3].y = (int)(rect4bX - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect4bPoints, 4, black);\n\n  // 修改第五個斜形（長度為 120）\n  gdPoint rect5Points[4];\n  int rect5X = rect4aX + 15 + rectSpacing;  // 第五個長方形\n  int rect5Y = rect4aY;\n  rect5Points[0].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) + (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[0].y = (int)(rect5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[1].x = (int)((rect5X + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[1].y = (int)((rect5X + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[2].x = (int)((rect5X + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect5Y + 120) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[2].y = (int)((rect5X + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect5Y + 120) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[3].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) + ((rect5Y + 120) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[3].y = (int)(rect5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect5Y + 120) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect5Points, 4, black);\n\n  // 添加新的黑色斜形（第六個，上半部分）\n  gdPoint rect6aPoints[4];\n  int rect6aX = rect5X + 15 + rectSpacing;  // 第六個長方形（上半部分）\n  int rect6aY = rect5Y;\n  rect6aPoints[0].x = (int)(rect6aX - centerX) * cos(rotationAngle * M_PI / 180) + (rect6aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[0].y = (int)(rect6aX - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6aPoints[1].x = (int)((rect6aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect6aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[1].y = (int)((rect6aX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6aPoints[2].x = (int)((rect6aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[2].y = (int)((rect6aX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6aPoints[3].x = (int)(rect6aX - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[3].y = (int)(rect6aX - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect6aPoints, 4, black);\n\n  // 添加新的黑色斜形（第六個，下半部分）\n  gdPoint rect6bPoints[4];\n  int rect6bX = rect5X + 15 + rectSpacing;  // 第六個長方形（下半部分）\n  int rect6bY = rect5Y + 55 + 10;  // 上半部分的 Y 座標 + 上半部分的高度 + 間隔\n  rect6bPoints[0].x = (int)(rect6bX - centerX) * cos(rotationAngle * M_PI / 180) + (rect6bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[0].y = (int)(rect6bX - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6bPoints[1].x = (int)((rect6bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect6bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[1].y = (int)((rect6bX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6bPoints[2].x = (int)((rect6bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[2].y = (int)((rect6bX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6bPoints[3].x = (int)(rect6bX - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[3].y = (int)(rect6bX - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect6bPoints, 4, black);}\n\n\n  // 添加新的黑色斜形（第四個，上半部分）\n  gdPoint rect4aPoints[4];\n  int rect4aX = 460;  // 第四個長方形（上半部分）\n  int rect4aY =185;\n  rect4aPoints[0].x = (int)(rect4aX - centerX) * cos(rotationAngle * M_PI / 180) - (rect4aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[0].y = (int)(rect4aX - centerX) * sin(rotationAngle * M_PI / 180) + (rect4aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4aPoints[1].x = (int)((rect4aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - (rect4aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[1].y = (int)((rect4aX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + (rect4aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4aPoints[2].x = (int)((rect4aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect4aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[2].y = (int)((rect4aX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect4aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4aPoints[3].x = (int)(rect4aX - centerX) * cos(rotationAngle * M_PI / 180) - ((rect4aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4aPoints[3].y = (int)(rect4aX - centerX) * sin(rotationAngle * M_PI / 180) + ((rect4aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect4aPoints, 4, black);\n\n  // 添加新的黑色斜形（第四個，下半部分）\n  gdPoint rect4bPoints[4];\n  int rect4bX = rect4aX;  // 使用与上半部分相同的X坐标\n  int rect4bY = rect4aY + 55 + 10;  // 上半部分的 Y 座標 + 上半部分的高度 + 間隔\n  rect4bPoints[0].x = (int)(rect4bX - centerX) * cos(rotationAngle * M_PI / 180) - (rect4bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[0].y = (int)(rect4bX - centerX) * sin(rotationAngle * M_PI / 180) + (rect4bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4bPoints[1].x = (int)((rect4bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - (rect4bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[1].y = (int)((rect4bX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + (rect4bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4bPoints[2].x = (int)((rect4bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect4bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[2].y = (int)((rect4bX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect4bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect4bPoints[3].x = (int)(rect4bX - centerX) * cos(rotationAngle * M_PI / 180) - ((rect4bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect4bPoints[3].y = (int)(rect4bX - centerX) * sin(rotationAngle * M_PI / 180) + ((rect4bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect4bPoints, 4, black);\n\n  // 修改第五個斜形（在上方添加）\n  gdPoint rect5Points[4];\n  int rect5X = rect4aX + 15 + rectSpacing;  // 第五個長方形\n  int rect5Y = rect4aY;\n  int middleRectWidth = 15;    // 中間長方形寬度\n  int middleRectHeight = 55;   // 中間長方形高度\n  int middleRectSpacing = 10;  // 中間長方形上下間隔\n  rect5Points[0].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) - (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[0].y = (int)(rect5X - centerX) * sin(rotationAngle * M_PI / 180) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[1].x = (int)((rect5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[1].y = (int)((rect5X + middleRectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[2].x = (int)((rect5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[2].y = (int)((rect5X + middleRectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect5Points[3].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) - ((rect5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect5Points[3].y = (int)(rect5X - centerX) * sin(rotationAngle * M_PI / 180) + ((rect5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect5Points, 4, black);\n\n\n  // 添加位於第五個斜形下方的新的黑色斜形\n  gdPoint rectBelow5Points[4];\n  int rectBelow5X = rect5X;\n  int rectBelow5Y = rect5Y + middleRectHeight + middleRectSpacing;\n  rectBelow5Points[0].x = (int)(rectBelow5X - centerX) * cos(rotationAngle * M_PI / 180) - (rectBelow5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[0].y = (int)(rectBelow5X - centerX) * sin(rotationAngle * M_PI / 180) + (rectBelow5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rectBelow5Points[1].x = (int)((rectBelow5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - (rectBelow5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[1].y = (int)((rectBelow5X + middleRectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + (rectBelow5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rectBelow5Points[2].x = (int)((rectBelow5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - ((rectBelow5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[2].y = (int)((rectBelow5X + middleRectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + ((rectBelow5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rectBelow5Points[3].x = (int)(rectBelow5X - centerX) * cos(rotationAngle * M_PI / 180) - ((rectBelow5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rectBelow5Points[3].y = (int)(rectBelow5X - centerX) * sin(rotationAngle * M_PI / 180) + ((rectBelow5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rectBelow5Points, 4, black);\n\n  // 第六個斜形（上半部分）\n  gdPoint rect6aPoints[4];\n  int rect6aX = rect5X + 15 + 10;  // 第六個長方形（上半部分）\n  int rect6aY = rect5Y;\n  rect6aPoints[0].x = (int)(rect6aX - centerX) * cos(rotationAngle * M_PI / 180) - (rect6aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[0].y = (int)(rect6aX - centerX) * sin(rotationAngle * M_PI / 180) + (rect6aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6aPoints[1].x = (int)((rect6aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - (rect6aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[1].y = (int)((rect6aX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + (rect6aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6aPoints[2].x = (int)((rect6aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect6aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[2].y = (int)((rect6aX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect6aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6aPoints[3].x = (int)(rect6aX - centerX) * cos(rotationAngle * M_PI / 180) - ((rect6aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6aPoints[3].y = (int)(rect6aX - centerX) * sin(rotationAngle * M_PI / 180) + ((rect6aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect6aPoints, 4, black);\n\n  // 第六個斜形（下半部分）\n  gdPoint rect6bPoints[4];\n  int rect6bX = rect6aX;  // 第六個長方形（下半部分）\n  int rect6bY = rect6aY + 55 + 10;  // 上半部分的 Y 座標 + 上半部分的高度 + 間隔\n  rect6bPoints[0].x = (int)(rect6bX - centerX) * cos(rotationAngle * M_PI / 180) - (rect6bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[0].y = (int)(rect6bX - centerX) * sin(rotationAngle * M_PI / 180) + (rect6bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6bPoints[1].x = (int)((rect6bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - (rect6bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[1].y = (int)((rect6bX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + (rect6bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6bPoints[2].x = (int)((rect6bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect6bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[2].y = (int)((rect6bX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect6bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n  rect6bPoints[3].x = (int)(rect6bX - centerX) * cos(rotationAngle * M_PI / 180) - ((rect6bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX;\n  rect6bPoints[3].y = (int)(rect6bX - centerX) * sin(rotationAngle * M_PI / 180) + ((rect6bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY;\n\n  gdImageFilledPolygon(rotated_im, rect6bPoints, 4, black);\n\n    output = fopen("output.png", "wb");\n    gdImagePng(rotated_im, output);\n    fclose(output);\n\n    gdImageDestroy(im);\n    gdImageDestroy(rotated_im);\n\n    return 0;\n}\n \n \n', 'tags': '', 'url': 'w8.html'}, {'title': 'W11-12', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\n// Declare the rotation function\nvoid rotateFilledPolygon(int x_orig, int y_orig, double rotation_ang, gdPoint *points, int num_points) {\n    int i;\n    double angle_rad = rotation_ang * M_PI / 180.0;\n\n    for (i = 0; i < num_points; i++) {\n        int x = points[i].x - x_orig;\n        int y = points[i].y - y_orig;\n\n        points[i].x = x_orig + (int)(x * cos(angle_rad) - y * sin(angle_rad));\n        points[i].y = y_orig + (int)(x * sin(angle_rad) + y * cos(angle_rad));\n    }\n}\n\nint main() {\n    // Image dimensions\n    int width = 800;\n    int height = 600;\n\n    // Create a true-color image\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    // Open the output file\n    FILE *outputFile = fopen("hellogd1.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n\n    // Define color indices\n    int red = gdImageColorAllocate(img, 255, 0, 0);\n    int blue = gdImageColorAllocate(img, 0, 0, 255);\n    int black = gdImageColorAllocate(img, 0, 0, 0);\n    int white = gdImageColorAllocate(img, 255, 255, 255);\n\n    // Draw filled rectangles, ellipse, line, and polygons\n    gdImageFilledRectangle(img, 0, 0, width, height, white);\n    gdImageFilledRectangle(img, 0, 0, (int)width / 4, (int)height / 4, blue);\n\n    gdImageFilledEllipse(img, (int)width * 3 / 4, (int)height / 4, (int)width / 4, (int)width / 4, red);\n    gdImageEllipse(img, (int)width * 3 / 4, (int)height * 3 / 4, (int)width / 4, (int)width / 4, red);\n    gdImageLine(img, (int)width / 2, (int)height / 2, (int)width / 2, (int)height / 2 + 100, blue);\n\n    gdPoint points[4] = {\n        { (int)width / 4, (int)height * 3 / 4 },\n        { (int)width / 4 + 100, (int)height * 3 / 4 },\n        { (int)width / 4 + 100, (int)height * 3 / 4 + 100 },\n        { (int)width / 4, (int)height * 3 / 4 + 100 }\n    };\n\n    // Call the rotation function for the first polygon\n    rotateFilledPolygon((int)width / 4 + 50, (int)height * 3 / 4 + 50, 45.0, points, 4);\n    gdImagePolygon(img, points, 4, black);\n\n    gdPoint points2[4] = {\n        { (int)width / 3, (int)height / 2 },\n        { (int)width / 3 + 100, (int)height / 2 },\n        { (int)width / 3 + 100, (int)height / 2 + 100 },\n        { (int)width / 3 - 50, (int)height / 2 + 100 }\n    };\n\n    // Call the rotation function for the second polygon\n    rotateFilledPolygon((int)width / 3 + 50, (int)height / 2 + 50, 30.0, points2, 4);\n    gdImageFilledPolygon(img, points2, 4, red);\n\n    // Save the image to the output file\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n\n    // Free the memory used by the image\n    gdImageDestroy(img);\n\n    return 0;\n}\n \n \n 先設定hello.c的檔 \n \n   #include <stdio.h>\n\nint main()\n{\n    printf("hello world\\n");\n} \n \n 然後再shell打cc hello.c會出現這個 \n \n 然後要回車這樣replit就會幫我準備好c \n 之後再進行一次程式 cc hello.c，然後打./a.out \n 然後就會出現hello world \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\n// Declare the rotation function\nvoid rotateFilledPolygon(int x_orig, int y_orig, double rotation_ang, gdPoint *points, int num_points) {\n    int i;\n    double angle_rad = rotation_ang * M_PI / 180.0;\n\n    for (i = 0; i < num_points; i++) {\n        int x = points[i].x - x_orig;\n        int y = points[i].y - y_orig;\n\n        points[i].x = x_orig + (int)(x * cos(angle_rad) - y * sin(angle_rad));\n        points[i].y = y_orig + (int)(x * sin(angle_rad) + y * cos(angle_rad));\n    }\n}\n\nint main() {\n    int width = 800;\n    int height = 600;\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    FILE *outputFile = fopen("hellogd2.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n\n    int red = gdImageColorAllocate(img, 255, 0, 0);\n    int blue = gdImageColorAllocate(img, 0, 0, 255);\n    int black = gdImageColorAllocate(img, 0, 0, 0);\n    int white = gdImageColorAllocate(img, 255, 255, 255);\n\n    gdImageFilledRectangle(img, 0, 0, width, height, white);\n    gdImageFilledRectangle(img, 0, 0, (int)width / 4, (int)height / 4, blue);\n\n    gdImageFilledEllipse(img, (int)width * 3 / 4, (int)height / 4, (int)width / 4, (int)width / 4, red);\n    gdImageEllipse(img, (int)width * 3 / 4, (int)height * 3 / 4, (int)width / 4, (int)width / 4, red);\n    gdImageLine(img, (int)width / 2, (int)height / 2, (int)width / 2, (int)height / 2 + 100, blue);\n\n    gdPoint points[4];\n    points[0].x = (int)width / 4;\n    points[0].y = (int)height * 3 / 4;\n    points[1].x = points[0].x + 100;\n    points[1].y = points[0].y;\n    points[2].x = points[1].x;\n    points[2].y = points[1].y + 100;\n    points[3].x = points[2].x - 100;\n    points[3].y = points[2].y;\n\n    // Call the rotation function multiple times\n    for (int i = 0; i < 4; i++) {\n        rotateFilledPolygon((int)width / 4 + 50, (int)height * 3 / 4 + 50, 30.0, points, 4);\n        gdImagePolygon(img, points, 4, black);\n    }\n\n    gdPoint points2[4];\n    points2[0].x = (int)width / 3;\n    points2[0].y = (int)height / 2;\n    points2[1].x = points2[0].x + 100;\n    points2[1].y = points2[0].y;\n    points2[2].x = points2[1].x;\n    points2[2].y = points2[1].y + 100;\n    points2[3].x = points2[2].x - 150;\n    points2[3].y = points2[2].y;\n\n    // Call the rotation function multiple times\n    for (int i = 0; i < 12; i++) {\n        //rotateFilledPolygon((int)width / 3 + 50, (int)height / 2 + 50, 30.0, points2, 4);\n        rotateFilledPolygon(500, 200, 30.0, points2, 4);\n        gdImageFilledPolygon(img, points2, 4, red);\n    }\n\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n\n    return 0;\n} \n \n', 'tags': '', 'url': 'W11-12.html'}, {'title': 'w13', 'text': '\n #include <stdio.h>\n\xa0\nint main() {\n// 開啟文件以寫入位移和速度數據\nFILE *outputFile = fopen("motion_data.txt", "w");\nif (!outputFile) {\nfprintf(stderr, "無法創建數據文件。\\n");\nreturn 1;\n}\n\xa0\n// 模擬運動 10 秒並計算位移和速度，同時將數據寫入文件\ndouble x = 0.2; // 初始位移\ndouble v = 0.0; // 初始速度\ndouble dt = 0.01; // 時間步長\ndouble t = 0.0; // 時間\n\xa0\nwhile (t <= 10.0) {\ndouble acceleration = (-10.0 * x - 0.5 * v) / 1.0; // 這裡修改了系統的參數\nv += acceleration * dt;\nx += v * dt;\n\xa0\nfprintf(outputFile, "%lf %lf %lf\\n", t, x, v);\n\xa0\nt += dt;\n}\n\xa0\n// 關閉數據文件\nfclose(outputFile);\n\xa0\n// 使用popen啟動Gnuplot進程\nFILE *gnuplotPipe = popen("gnuplot -persistent", "w");\nif (!gnuplotPipe) {\nfprintf(stderr, "無法啟動Gnuplot。\\n");\nreturn 1;\n}\n\xa0\n// 使用Gnuplot繪圖指令，指定字型文件和輸出PNG\nfprintf(gnuplotPipe, "set terminal png font \'default,12\' size 800,400\\n");\nfprintf(gnuplotPipe, "set output \'./../images/motion_plot.png\'\\n");\nfprintf(gnuplotPipe, "set title \'displacement and velocity vs. time\'\\n");\nfprintf(gnuplotPipe, "set xlabel \'time (s)\'\\n");\nfprintf(gnuplotPipe, "set ylabel \'displacement (m)\'\\n");\nfprintf(gnuplotPipe, "plot \'motion_data.txt\' using 1:2 with lines lw 2 title \'displacement\', \\\n\'motion_data.txt\' using 1:3 with lines lw 2 title \'velocity\'\\n");\n\xa0\n// 關閉Gnuplot進程\nfprintf(gnuplotPipe, "exit\\n");\npclose(gnuplotPipe);\n\xa0\nreturn 0;\n} \n \n \n', 'tags': '', 'url': 'w13.html'}, {'title': 'w15', 'text': '\n \n 1. 根據\xa0 roc_list_coord_flag.7z \xa0 程式內容所印出的六組 ABED 等繪製 ROC 國旗白日圖案中的菱形四個關鍵點, 請直接在青天與滿地紅的圖案中, 利用白色作為畫線顏色, 將第二組的 ABED 等四個點的座標, 以直線相連. \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n \nvoid draw_roc_flag(gdImagePtr img);\nvoid draw_white_sun(gdImagePtr img, int x, int y, int size, int color);\n \nint main() {\n    // width 3: height 2\n    int width = 1200;\n    // 國旗長寬比為 3:2\n    int height = (int)(width * 2.0 / 3.0);\n \n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n \n    draw_roc_flag(img);\n \n    FILE *outputFile = fopen("roc_flag_in_gd.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n \nvoid draw_roc_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white, blue;\n \n    // 白日位於青天面積正中央, 因此中心點座標為長寬各 1/4 處\n    int center_x = (int)(width / 4);\n    int center_y = (int)(height / 4);\n \n    int sun_radius = (int)(width / 8);\n    int white_circle_dia = sun_radius;\n    int blue_circle_dia = white_circle_dia + white_circle_dia * 2 / 15;\n \n    red = gdImageColorAllocate(img, 255, 0, 0); // 紅色\n    white = gdImageColorAllocate(img, 255, 255, 255); // 白色\n    blue = gdImageColorAllocate(img, 0, 0, 149); // 藍色\n \n    gdImageFilledRectangle(img, 0, 0, width, height, red);\n    gdImageFilledRectangle(img, 0, 0, (int)(width / 2.0), (int)(height / 2.0), blue);\n    draw_white_sun(img, center_x, center_y, sunS_radius, white);\n    gdImageFilledEllipse(img, center_x, center_y, blue_circle_dia, blue_circle_dia, blue);\n    gdImageFilledEllipse(img, center_x, center_y, white_circle_dia, white_circle_dia, white);\n \n    // 在青天與滿地紅的圖案中以白色畫線繪製連接菱形的四個關鍵點\n    gdImageSetThickness(img, 10); // 設置線條粗度為10\n    gdImageLine(img, 429, 125, 279, 165, white);\n    gdImageLine(img, 279, 165, 170, 274, white);\n    gdImageLine(img, 170, 274, 170, 274, white);\n    gdImageLine(img, 429, 125, 170, 274, white); // 加入第四條連線\n}\nvoid draw_white_sun(gdImagePtr img, int x, int y, int size, int color) {\n    // 實現 draw_white_sun 函數的內容\n    // 可以在此處繪製白日的內部圖案\n}\n \n 2. 承上題, 請列出第二組 ABED 的四條直線與白日中的大圓所相交 (intersect) 的四個點座標. \n', 'tags': '', 'url': 'w15.html'}, {'title': 'w16', 'text': '第一題 \n #include <stdio.h>\n#include <gd.h>\n \n// Function to draw the mass-spring-damper system\nvoid draw_system(const char* filename) {\n    int width = 600;\n    int height = 300;\n    int x_margin = 50;\n    int y_margin = 50;\n    int mass_radius = 20;\n    int spring_width = 4;\n    int damper_width = 4;\n \n    gdImagePtr img = gdImageCreate(width, height);\n    int background_color = gdImageColorAllocate(img, 255, 255, 255);\n    int mass_color = gdImageColorAllocate(img, 0, 0, 0);\n    int spring_color = gdImageColorAllocate(img, 0, 0, 0);\n    int damper_color = gdImageColorAllocate(img, 0, 0, 0);\n    int wall_color = gdImageColorAllocate(img, 0, 0, 0);\n \n    // Draw left wall\n    gdImageLine(img, x_margin, y_margin, x_margin, height - y_margin, wall_color);\n \n    // Draw mass 1\n    int x1 = x_margin + 2 * mass_radius;\n    int y1 = height / 2;\n    gdImageFilledEllipse(img, x1, y1, mass_radius, mass_radius, mass_color);\n \n    // Draw spring 1\n    int spring1_start_x = x_margin;\n    int spring1_end_x = x1 - mass_radius;\n    int spring1_y = y1;\n    gdImageLine(img, spring1_start_x, spring1_y, spring1_end_x, spring1_y, spring_color);\n    gdImageSetThickness(img, spring_width);\n    gdImageLine(img, spring1_start_x, spring1_y, spring1_end_x, spring1_y, spring_color);\n    gdImageSetThickness(img, 1);\n \n    // Draw damper 1\n    int damper1_start_x = x_margin / 2;\n    int damper1_end_x = x1 - mass_radius;\n    int damper1_y = y1;\n    gdImageLine(img, damper1_start_x, damper1_y, damper1_end_x, damper1_y, damper_color);\n    gdImageSetThickness(img, damper_width);\n    gdImageLine(img, damper1_start_x, damper1_y, damper1_end_x, damper1_y, damper_color);\n    gdImageSetThickness(img, 1);\n \n    // Draw mass 2\n    int x2 = width - x_margin - 2 * mass_radius;\n    int y2 = height / 2;\n    gdImageFilledEllipse(img, x2, y2, mass_radius, mass_radius, mass_color);\n \n    // Draw spring 2\n    int spring2_start_x = x2 + mass_radius;\n    int spring2_end_x = width - x_margin;\n    int spring2_y = y2;\n    gdImageLine(img, spring2_start_x, spring2_y, spring2_end_x, spring2_y, spring_color);\n    gdImageSetThickness(img, spring_width);\n    gdImageLine(img, spring2_start_x, spring2_y, spring2_end_x, spring2_y, spring_color);\n    gdImageSetThickness(img, 1);\n \n    // Draw damper 2\n    int damper2_start_x = width - x_margin + mass_radius;\n    int damper2_end_x = x2 + mass_radius;\n    int damper2_y = y2;\n    gdImageLine(img, damper2_start_x, damper2_y, damper2_end_x, damper2_y, damper_color);\n    gdImageSetThickness(img, damper_width);\n    gdImageLine(img, damper2_start_x, damper2_y, damper2_end_x, damper2_y, damper_color);\n    gdImageSetThickness(img, 1);\n \n    // Draw right wall\n    gdImageLine(img, width - x_margin, y_margin, width - x_margin, height - y_margin, wall_color);\n \n    // Save the image to a file\n    FILE *output_file = fopen(filename, "wb");\n    gdImagePng(img, output_file);\n    fclose(output_file);\n \n    // Free the memory used by the image\n    gdImageDestroy(img);\n}\n \nint main() {\n    draw_system("mass_spring_damper_system.png");\n    return 0;\n} \n 第二題 \n #include <stdio.h>\n \n// System parameters\n#define M1 2.0\n#define M2 3.0\n#define K1 0.5\n#define K2 1.0\n#define K3 15.0\n#define C1 0.25\n#define C2 0.33\n#define C3 0.5\n \n// Function to calculate the derivative of the state\nvoid calculate_derivative(double t, double state[4], double derivative[4]) {\n    derivative[0] = state[2];  // dx1/dt = v1\n    derivative[1] = state[3];  // dx2/dt = v2\n \n    double delta_x = state[0] - state[1];\n \n    // dv1/dt\n    derivative[2] = -(K1 * state[0] + K2 * delta_x) / M1;\n \n    // dv2/dt\n    derivative[3] = -(K3 * state[1] - K2 * delta_x) / M2;\n}\n \n// Euler\'s Method for solving the system\nvoid euler_method(double t_initial, double t_final, double dt, double initial_conditions[4]) {\n    FILE *output_file;\n    output_file = fopen("trajectory_data.txt", "w");\n \n    double t = t_initial;\n    double state[4];\n    for (int i = 0; i < 4; ++i) {\n        state[i] = initial_conditions[i];\n    }\n \n    while (t <= t_final) {\n        fprintf(output_file, "%f %f %f %f %f\\n", t, state[0], state[1], state[2], state[3]);\n \n        double derivative[4];\n        calculate_derivative(t, state, derivative);\n \n        for (int i = 0; i < 4; ++i) {\n            state[i] += derivative[i] * dt;\n        }\n \n        t += dt;\n    }\n \n    fclose(output_file);\n}\n \nint main() {\n    // Define the initial conditions\n    double initial_conditions[4] = {1.0, -0.5, 0.0, 0.0};  // x1, x2, v1, v2\n \n    // Time parameters\n    double t_initial = 0.0;\n    double t_final = 10.0;\n    double dt = 0.01;\n \n    // Solve the system using Euler\'s Method\n    euler_method(t_initial, t_final, dt, initial_conditions);\n \n    return 0;\n} \n \n', 'tags': '', 'url': 'w16.html'}, {'title': 'cEX', 'text': '', 'tags': '', 'url': 'cEX.html'}, {'title': '課程1', 'text': '\n \n \n 1. \n #include <stdio.h>\n\nint main()\n{\nfloat a = 0.5;\ndouble b = 1.2;\nint c = 3;\nb = b + a + c;\n\n/* 输出 a, b, c 到屏幕 */\nprintf("a = %3.1f, b = %3.1f, c = %d\\n", a, b, c);\n\nreturn 0;\n} \n \n 2. \n /* ====================\n   字元範例 1\n   ==================== */\n#include <stdio.h>\n\nint main()\n{\n    char x, y;\n\n    x = \'a\';\n    y = (char)97;\n\n    /* 輸出 x, y, x, 最後一個是以 ASCII 值顯示 y */\n    printf("x = %c, y = %c, ASCII of y = %d", x, y, y);\n\n    return 0;\n}\n \n \n 3. \n #include <stdio.h>\n\nint main()\n{\n    int a = 64;\n    int b = 0x40; // 以十六进制表示\n    long c = 64L;\n\n    // 打印变量的值\n    printf("%d, %d, %ld", a, b, c);\n\n    return 0;\n}\n \n \n 4. \n #include <stdio.h>\n\nint main()\n{\n    int a = 10, b = 5;\n\n    // 第一组比较\n    printf("a == b is %d\\n", a == b);\n    printf("a > b is %d\\n", a > b);\n    printf("a < b is %d\\n", a < b);\n    printf("a >= b is %d\\n", a >= b);\n    printf("a <= b is %d\\n", a <= b);\n    printf("a != b is %d\\n", a != b);\n\n    printf("\\n");\n\n    // 修改 b 的值\n    b = 10;\n\n    // 第二组比较\n    printf("a == b is %d\\n", a == b);\n    printf("a > b is %d\\n", a > b);\n    printf("a < b is %d\\n", a < b);\n    printf("a >= b is %d\\n", a >= b);\n    printf("a <= b is %d\\n", a <= b);\n    printf("a != b is %d\\n", a != b);\n\n    return 0;\n}\n \n \n 5. \n #include <stdio.h>\n\nvoid main()\n{\nint a;\n\n// 第一次输出\na = 3;\nprintf("%d\\n", !a); // 逻辑非运算，a为真，所以输出0\n\n// 第二次输出\na = 0;\nprintf("%d\\n", !a); // 逻辑非运算，a为假，所以输出1\n}\n\n \n \n 6. \n #include <stdio.h>\n\nvoid main()\n{\n    char a;\n\n    // 使用 %zu 格式说明符输出 size_t 类型\n    printf("The size of int is %zu\\n", sizeof(int));\n\n    // 使用 %zu 格式说明符输出 size_t 类型\n    printf("The size of char a is %zu\\n", sizeof(a));\n}\n \n \n 7. \n #include <stdio.h>\n\n/* ====================\n计算长方形面积, 需传入长与宽.\n==================== */\nint rect(int x, int y)\n{\n    int result;\n    result = x * y;\n    return result; /* 返回 result */\n}\n\n/* ====================\n主函数\n==================== */\nint main()\n{\n    int x = 8, y = 4;\n    int a;\n    a = rect(x, y);\n    printf("8*4 的面积是 %d", a);\n    return 0;\n}\n \n \n 8. \n #include <stdio.h>\nfloat circle( int r ); /* 宣告 circle 的 prototype */\nvoid main()\n{\nfloat answer;\nanswer = circle(8);\nprintf( " 圓周長度是 %f", answer );\n}\n/* ====================\n circle 函數, 計算 circle 的圓周長\n==================== */\nfloat circle( int r )\n{\nfloat result;\nresult = 3.14159 * (double)1001 * r;\nreturn ( result );\n}\n \n \n 9, \n #include <stdio.h>\n\nint main()\n{\n    char ch;\n\n    printf("输入一个字符：");\n\n    // 检查 scanf 的返回值，确保成功读取一个字符\n    if (scanf(" %c", &ch) != 1) {\n        printf("读取字符失败\\n");\n        return 1; // 或者采取其他错误处理措施\n    }\n\n    if (ch == \'a\') {\n        printf("您按下了 \'a\'\\n");\n    }\n\n    return 0;\n}\n \n \n 10. \n #include <stdio.h>\n\nvoid main()\n{\n    int i;\n\n    // 提示用户输入一个整数\n    printf("100：");\n\n    // 读取用户输入的整数\n    scanf("%d", &i);\n\n    // 判断输入的整数，并输出相应的消息\n    if (i < 100)\n    {\n        printf("i < 100\\n");\n    }\n    else\n    {\n        if ((i >= 100) && (i < 200))\n        {\n            printf("i >= 100 且 i < 200\\n");\n        }\n        else\n        {\n            printf("i >= 200\\n");\n        }\n    }\n}\n \n \n 1.1 \n /* =========================\n function pointer 2\n========================= */\n#include <stdio.h>\n/* ====================\nsay “Hello”.\n==================== */\nvoid Hello(void)\n{\nprintf(“ Hello\\n”);\n}\n/* ====================\nsay “World”.\n==================== */\nvoid World(void)\n{\nprintf(“ World\\n”);\n}\n/* ====================\nmain function.\n==================== */\nint main()\n{\nvoid (*func[3])(void); /* 宣告一個 function pointer array */\nint i = 0 ;\nfunc[0] = Hello; /* 建立 Jumping table */\nfunc[1] = World;\nwhile(1)\n{\nprintf(“Input a number between 0 and 1 : ”);\nscanf( “%d”,&i );\n/* 若 I 大於等於 2 或是小於 0 則離開 loop */\nif( (i >= 2)||(i < 0) )\nbreak;\nelse\nfunc[ i ]( ); /* 執行! */\n}\nreturn 0;\n} \n \n \n \n 1.2 \n   #include <stdio.h>\n\n  /* ====================\n  say “Hello”.\n  ==================== */\n  void Hello(void)\n  {\n      printf("Hello\\n");\n  }\n\n  /* ====================\n  say “World”.\n  ==================== */\n  void World(void)\n  {\n      printf("World\\n");\n  }\n\n  /* ====================\n  main function.\n  ==================== */\n  int main()\n  {\n      void (*func[3])(void); /* 声明一个函数指针数组 */\n      int i = 0;\n\n      func[0] = Hello; /* 建立 Jumping table */\n      func[1] = World;\n\n      while (1)\n      {\n          printf("Input a number between 0 and 1: ");\n          scanf("%d", &i);\n\n          /* 如果 i 大于等于 2 或小于 0 则退出循环 */\n          if (i >= 2 || i < 0)\n              break;\n          else\n              func[i](); /* 执行函数 */\n      }\n\n      return 0;\n  }\n \n \n 1.3 \n #include <stdio.h>\n\n/* ====================\nsay “Hello”.\n==================== */\nvoid Hello(void)\n{\n    printf("Hello\\n");\n}\n\n/* ====================\nsay “World”.\n==================== */\nvoid World(void)\n{\n    printf("World\\n");\n}\n\n/* ====================\nmain function.\n==================== */\nint main()\n{\n    void (*func[3])(void); /* 声明一个函数指针数组 */\n    int i = 0;\n\n    func[0] = Hello; /* 建立 Jumping table */\n    func[1] = World;\n\n    while (1)\n    {\n        printf("Input a number between 0 and 1: ");\n\n        // 检查 scanf 的返回值，确保成功读取一个整数\n        if (scanf("%d", &i) != 1)\n        {\n            printf("无效输入，请输入一个整数。\\n");\n            break;\n        }\n\n        /* 如果 i 大于等于 2 或小于 0 则退出循环 */\n        if (i >= 2 || i < 0)\n            break;\n        else\n            func[i](); /* 执行函数 */\n    }\n\n    return 0;\n}  \n \n 2.1 \n /* ====================\n pointer to pointer – 1.\n==================== */\n#include <stdio.h>\nint main()\n{\nchar *Hello = “Hello”;\nchar *World = “World”;\nchar *GoodBye = “Good Bye”;\nchar *StrArray[3];\nchar **Str;\nint i;\nStr = StrArray;\nStrArray[0] = Hello;\nStrArray[1] = World;\nStrArray[2] = GoodBye;\nfor( i = 0; i < 3; i++ )\n{\nprintf(“%s”, StrArray[ i ] );\n}\nfor( i = 0; i < 3; i++ )\n{\nprintf(“%s”, *Str );\nStr++;\n}\nretur \n 2.2 \n /* ====================\n pointer to pointer – 1.\n==================== */\n#include <stdio.h>\n\nint main() {\n    char *Hello = "Hello";\n    char *World = "World";\n    char *GoodBye = "Good Bye";\n    char *StrArray[3];\n    char **Str;\n    int i;\n\n    Str = StrArray;\n    StrArray[0] = Hello;\n    StrArray[1] = World;\n    StrArray[2] = GoodBye;\n\n    // Print strings using array indexing\n    for (i = 0; i < 3; i++) {\n        printf("%s ", StrArray[i]);\n    }\n\n    // Print strings using pointer arithmetic\n    Str = StrArray;  // Reset the pointer to the beginning\n    for (i = 0; i < 3; i++) {\n        printf("%s ", *Str);\n        Str++;\n    }\n\n    return 0;\n}\n \n \xa0 \n 我的圖片不知道為甚麼不能傳所以我用打字說明 \n 先打cc ex.2-1.c再來打./a.out\xa0Hello World Good Bye Hello World Good Bye\n\n#include <stdio.h>\n\nint main() {\nprintf("int 类型的大小为 %zu 字节\\n", sizeof(int));\n\nchar a;\nprintf("char 类型变量 a 的大小为 %zu 字节\\n", sizeof(a));\n\nreturn 0;\n} \n \n #include <stdio.h>\n\nint main() {\nfloat this_is_a_number1, this_is_a_number2;\nint scanf_result; // Dummy variable to capture scanf\'s return value\n\n/* 读取输入的浮点数 */\nscanf_result = scanf("%f", &this_is_a_number1);\n\n/* 读取输入的浮点数 */\nscanf_result = scanf("%f", &this_is_a_number2);\n\n/* Your code here */\n\nreturn 0;\n}\n\n \n \n', 'tags': '', 'url': '課程1.html'}, {'title': '練習1', 'text': '1. \n /* =========================\n struct – 3.\n========================= */\n#include <stdio.h>\n#include <string.h>\n\n/* ====================\n struct Mouse.\n==================== */\nstruct Mouse\n{\n    int xPos, yPos;\n    char Name[10];\n};\n\n/* ====================\n Copy Mouse 1\n==================== */\nvoid cpyMouse1(struct Mouse *tgt, struct Mouse *src)\n{\n    tgt->xPos = src->xPos;\n    tgt->yPos = src->yPos;\n    strcpy(tgt->Name, src->Name);\n}\n\n/* ====================\n main function.\n==================== */\nint main()\n{\n    struct Mouse myMouse, yourMouse;\n\n    yourMouse.xPos = 10;\n    yourMouse.yPos = 20;\n    strcpy(yourMouse.Name, "Mickey");\n\n    cpyMouse1(&myMouse, &yourMouse);\n\n    printf("Name: %s, X: %d, Y: %d\\n", myMouse.Name, myMouse.xPos, myMouse.yPos);\n\n    return 0;\n}\n \n \n 2. \n /* =========================\n #define 的範例 2.\n========================= */\n#include <stdio.h>\n\n#define TRUE 1\n#define FALSE 0\n#define BOOL int\n\n/* ====================\n如果傳入值大於 10, 則傳回 TRUE\n==================== */\nBOOL is_greater_than_10(int i)\n{\n    if (i > 10)\n        return TRUE;\n    else\n        return FALSE;\n}\n\n/* ====================\n main function.\n==================== */\nint main()\n{\n    int i;\n    BOOL result;\n\n    printf("Input a number: ");\n\n    // 檢查 scanf 的返回值\n    if (scanf("%d", &i) != 1) {\n        printf("Error reading input.\\n");\n        return 1;  // 返回非零值表示錯誤\n    }\n\n    result = is_greater_than_10(i);\n\n    if (result == TRUE)\n        printf("Greater than 10!\\n"); /* 大於 10 */\n    else\n        printf("Not greater than 10!\\n"); /* 不大於 10 */\n\n    return 0;\n}\n \n \n 3. \n /* ====================\n & operator.\n==================== */\n#include <stdio.h>\n\nint main()\n{\n    int *pointer_a, a;\n    pointer_a = &a;\n    a = 10;\n\n    printf("%d, %d\\n", a, *pointer_a);\n\n    return 0;\n}\n \n \n 4. \n /* ====================\npointer – 6\n==================== */\n#include <stdio.h>\n\nint main()\n{\nchar *str = "Eric";\n\nprintf("%c\\n", *(str + 0)); /* 也可寫 printf("%c", str[0] ); */\nprintf("%c\\n", *(str + 1)); /* 也可寫 printf("%c", str[1] ); */\nprintf("%c\\n", *(str + 2)); /* 也可寫 printf("%c", str[2] ); */\nprintf("%c\\n", *(str + 3)); /* 也可寫 printf("%c", str[3] ); */\n\nreturn 0;\n} \n 5. \n /* ====================\n 2d array.\n==================== */\n#include <stdio.h>\n\nint main()\n{\n    int array[3][3];\n    int x, y;\n\n    array[0][0] = 1;\n    array[0][1] = 2;\n    array[0][2] = 3;\n    array[1][0] = 4;\n    array[1][1] = 5;\n    array[1][2] = 6;\n    array[2][0] = 7;\n    array[2][1] = 8;\n    array[2][2] = 9;\n\n    for (x = 0; x < 3; x++)\n    {\n        for (y = 0; y < 3; y++)\n        {\n            printf("%d,", array[x][y]);\n        }\n    }\n\n    return 0;\n}\n \n \n 6. \n /* ====================\n array - 1.\n==================== */\n#include <stdio.h>\n\nint main()\n{\n    int grade[5]; /* size = 5 的 array */\n    int i;\n\n    grade[0] = 75; /* 1st element */\n    grade[1] = 80; /* 2nd element */\n    grade[2] = 85; /* 3rd element */\n    grade[3] = 70; /* 4th element */\n    grade[4] = 90; /* 5th element */\n\n    for (i = 0; i < 5; i++)\n    {\n        printf("Number %d = %d\\n", i, grade[i]);\n    }\n\n    return 0;\n}\n \n \n 7. \n /* ====================\n do - while.\n==================== */\n#include <stdio.h>\n\nint main()\n{\n    int i, j;\n    i = 0;\n    j = 10; /* 迴圈外先設定初值 */\n\n    do\n    {\n        printf("i = %d, ", i);\n        printf("j = %d\\n", j);\n        i++;\n        j++;\n    } while (i < 6); /* 檢查條件的地方 */\n\n    return 0;\n}\n \n \n 8. \n /* ====================\n99 乘法.\n==================== */\n#include <stdio.h>\n\nint main()\n{\n    int x, y;\n\n    for (x = 1; x <= 9; x++)\n    {\n        for (y = 1; y <= 9; y++)\n        {\n            printf("%2d ", x * y);  /* 使用 %2d 以確保數字的對齊性 */\n        }\n        printf("\\n");\n    }\n\n    return 0;\n}\n \n \n 9. \n /* ====================\n Program "continue"\n ==================== */\n#include <stdio.h>\n\nint main()\n{\n    int i;\n\n    for (i = 0; i < 10; i++)\n    {\n        if ((i == 1) || (i == 2) || (i == 3))\n        {\n            continue; /* 忽略以後的 program, 回到 for. */\n        }\n        printf("i = %d\\n", i);\n    }\n\n    return 0;\n}\n \n \n 10. \n /* ====================\nswitch - case 的範例 3.\n==================== */\n#include <stdio.h>\n\nint main()\n{\n    char c;\n\n    printf("Input a char: ");\n\n    // 檢查 scanf 的返回值\n    if (scanf("%c", &c) != 1)\n    {\n        printf("Error reading input.\\n");\n        return 1; // 返回非零值表示錯誤\n    }\n\n    switch (c)\n    {\n    case \'a\':\n        printf("You pressed a\\n");\n        break;\n    case \'b\':\n        printf("You pressed b\\n");\n        break;\n    case \'c\':\n        printf("You pressed c\\n");\n        break;\n    default:\n        printf("Unrecognized input\\n");\n        break;\n    }\n\n    return 0;\n}\n \n \n', 'tags': '', 'url': '練習1.html'}, {'title': 'ANSIC', 'text': '', 'tags': '', 'url': 'ANSIC.html'}, {'title': '課程2', 'text': '#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n, x = 0;\n\n    printf("\\n\\n Check whether a given number is an ugly number:\\n");\n    printf("----------------------------------------------------\\n");\n\n    // 检查 scanf 的返回值\n    if (scanf("%d", &n) != 1) {\n        printf("Input is not a valid integer.\\n");\n        return 1;  // 退出程序，表示出现错误\n    }\n\n    if (n <= 0) {\n        printf("Input a correct number.\\n");\n    } else {\n        while (n != 1) {\n            if (n % 5 == 0) {\n                n /= 5;\n            } else if (n % 3 == 0) {\n                n /= 3;\n            } else if (n % 2 == 0) {\n                n /= 2;\n            } else {\n                printf("It is not an ugly number.\\n");\n                x = 1;\n                break;\n            }\n        }\n\n        if (x == 0) {\n            printf("It is an ugly number.\\n");\n        }\n    }\n\n    return 0;\n}\n \n \n \n \n #include <stdio.h>\n#include <time.h>\n\nint main(void)\n{\n    time_t epoch = 0;\n\n    printf("\\n自纪元开始以来的秒数：%ld\\n", (long)epoch);\n    printf("对应的日期和时间：%s\\n", asctime(gmtime(&epoch)));\n\n    return 0;\n}\n \n \n \n \n #define __STDC_WANT_LIB_EXT1__ 1\n#include <stdio.h>\n#include <time.h>\n\nint main(void)\n{\n    time_t t = time(NULL);\n    printf("\\nThe calendar time expressed as a local Time is :");\t\n    printf("\\nUTC:   %s", asctime(gmtime(&t)));\n    printf("local: %s\\n", asctime(localtime(&t)));\n\n#ifdef __STDC_LIB_EXT1__\n    struct tm buf;\n    char str[26];\n\n    asctime_s(str, sizeof str, gmtime_s(&t, &buf));\n    printf("UTC:   %s", str);\n\n    asctime_s(str, sizeof str, localtime_s(&t, &buf));\n    printf("local: %s", str);\n#endif\n\n    return 0;\n}\n \n \n #include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n\nint main(void)\n{\n    // 设置时区为“Asia/Calcutta”\n    setenv("TZ", "/usr/share/zoneinfo/Asia/Calcutta", 1);   \n\n    // 获取并打印当前日期和时间\n    struct tm tm = *localtime(&(time_t){time(NULL)});\n    printf("\\n今天是 :            %s", asctime(&tm));\n    printf("(夏令时 %s)\\n", tm.tm_isdst ? "生效中" : "未生效");\n\n    // 将月份减去 24，表示 24 个月前的日期和时间\n    tm.tm_mon -= 24;  \n\n    // 重新计算时间\n    mktime(&tm);       \n\n    // 获取并打印 24 个月前的日期和时间\n    printf("\\n24个月前的日期是 : %s", asctime(&tm));\n    printf("(夏令时 %s)\\n\\n", tm.tm_isdst ? "生效中" : "未生效");\n\n    return 0;\n}\n \n \n \n \n #include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n\nint main(void)\n{\n    // 设置时区为“Asia/Calcutta”\n    setenv("TZ", "/usr/share/zoneinfo/Asia/Calcutta", 1);   \n\n    // 获取并打印当前日期和时间\n    struct tm tm = *localtime(&(time_t){time(NULL)});\n    printf("\\n今天是 :            %s", asctime(&tm));\n    printf("(夏令时 %s)\\n", tm.tm_isdst ? "生效中" : "未生效");\n\n    // 将月份减去 24，表示 24 个月前的日期和时间\n    tm.tm_mon -= 24;  \n\n    // 重新计算时间\n    mktime(&tm);       \n\n    // 获取并打印 24 个月前的日期和时间\n    printf("\\n24个月前的日期是 : %s", asctime(&tm));\n    printf("(夏令时 %s)\\n\\n", tm.tm_isdst ? "生效中" : "未生效");\n\n    return 0;\n}\n \n \n \n \n #include <stdio.h>\n#include <limits.h>\n\ndouble powxn(double x, int n) {\n    double k;\n    if (n == 0) return 1;\n    k = powxn(x * x, n / 2);\n    if (n % 2) k = k * x;\n    return k;\n}\n\nint main(void)\n{\n    double x = 7.0;\n    int n = 2;\n    printf("\\nx = %f, y = %d  ", x, n);\n    printf("\\nResult:(x^n) : %f ",powxn(x, n));\n    x = 6.2;\n    n = 3;\n    printf("\\n\\nx = %f, y = %d  ", x, n);\n    printf("\\nResult:(x^n) : %f ",powxn(x, n));\n    return 0;\n} \n \n \n \n //Source: https://bit.ly/2KNsta8\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nchar* fractionToDecimal(int numerator, int denominator) {\n    char *p;\n    int psz, n, *dec, dsz, x;\n    long long num, den, k, f;\n    int i, repeat_at;\n    int neg = 0;\n\n    psz = dsz = 100; n = x = 0;\n    p = malloc(psz * sizeof(char));\n\n    neg = ((numerator > 0 && denominator < 0) ||\n           (numerator < 0 && denominator > 0)) ? 1 : 0;\n    num = numerator;\n    den = denominator;\n    num = (num < 0) ? -num : num;\n    den = (den < 0) ? -den : den;\n\n    k = num / den;\n    f = num % den;\n\n    if (neg && (k || f)) p[n ++] = \'-\';\n\n    n += sprintf(&p[n], "%lld", k);\n    if (!f) {\n        p[n] = 0;\n        return p;\n    }\n\n    p[n ++] = \'.\';\n\n    dec = malloc(dsz * sizeof(int));\n\n    repeat_at = -1;\n    if (f < 0) f = -f;\n    while (f) {\n        for (i = 0; i < x; i += 2) {\n            if (dec[i] == f) {\n                repeat_at = i;\n                goto done;\n            }\n        }\n        if (x + 1 >= dsz) {\n            dsz *= 2;\n            dec = realloc(dec, dsz * sizeof(int));\n        }\n        dec[x ++] = f;\n        f *= 10;\n        k = f / den;\n        dec[x ++] = k;\n        f = f % den;\n    }\n\ndone:\n    for (i = 0; i < x; i += 2) {\n        if (n + 3 > psz) {\n            psz *= 2;\n            p = realloc(p, psz * sizeof(char));\n        }\n        if (repeat_at == i) {\n            p[n ++] = \'(\';\n        }\n        p[n ++] = \'0\' + dec[i + 1];\n    }\n    if (repeat_at != -1) p[n ++] = \')\';\n    p[n ++] = 0;\n\n    free(dec);\n\n    return p;\n}\n\nint main(void)\n{\n    int n = 3;\n    int d = 2;\n    printf("\\nn = %d, d = %d  ", n, d);\n    printf("\\nFractional part: %s ", fractionToDecimal(n, d));\n\n    n = 4;\n    d = 7;\n    printf("\\n\\nn = %d, d = %d  ", n, d);\n    printf("\\nFractional part: %s ", fractionToDecimal(n, d));\n\n    return 0;\n}\n \n \n \n \n \n #include <stdio.h>\n\nint main() {\n    int fno, sno, *ptr, *qtr, sum;  // 宣告整數變數 fno, sno, sum，以及整數指標 ptr, qtr\n\n    printf("\\n\\n Pointer : Add two numbers :\\n");\n    printf("--------------------------------\\n");\n\n    printf(" Input the first number : ");\n    // 檢查 scanf 的返回值，確保成功讀取一個整數\n    if (scanf("%d", &fno) != 1) {\n        fprintf(stderr, "Error: Invalid input for the first number.\\n");\n        return 1;\n    }\n\n    printf(" Input the second number : ");\n    // 檢查 scanf 的返回值，確保成功讀取一個整數\n    if (scanf("%d", &sno) != 1) {\n        fprintf(stderr, "Error: Invalid input for the second number.\\n");\n        return 1;\n    }\n\n    ptr = &fno;  // 將 fno 的地址賦值給指標 ptr\n    qtr = &sno;  // 將 sno 的地址賦值給指標 qtr\n\n    sum = *ptr + *qtr;  // 解參考 ptr 和 qtr，取得值並計算它們的和\n\n    printf(" The sum of the entered numbers is : %d\\n\\n", sum);  // 輸出輸入數字的總和\n\n    return 0;\n}\n \n \n \n \n \n #include <stdio.h>\n\nint main() {\n    int arr[10];  // 宣告一個大小為10的整數數組，用於存儲使用者輸入的整數\n    int i;\n\n    // 提示用戶輸入十個整數\n    printf("\\n\\nRead and Print elements of an array:\\n");\n    printf("-----------------------------------------\\n");\n    printf("Input 10 elements in the array :\\n");\n\n    // 使用迴圈接受用戶輸入，並將整數存入數組\n    for (i = 0; i < 10; i++) {\n        printf("element - %d : ", i);\n\n        // 檢查 scanf 的返回值，確保成功讀取一個整數\n        if (scanf("%d", &arr[i]) != 1) {\n            fprintf(stderr, "Error: Invalid input for element %d.\\n", i);\n            return 1;  // 如果輸入無效，返回錯誤碼\n        }\n    }\n\n    // 顯示數組中的所有元素\n    printf("\\nElements in array are: ");\n    for (i = 0; i < 10; i++) {\n        printf("%d  ", arr[i]);\n    }\n\n    printf("\\n");\n    return 0;\n}\n \n \n \n \n #include <stdio.h>\n\nint main() {\n    int days, years, weeks;\n\n    days = 1329; // 總天數\n\n    // 將天數轉換為年、週和天\n    years = days / 365;  // 計算年數\n    weeks = (days % 365) / 7;  // 計算週數\n    days = days % 7;  // 計算剩餘的天數\n\n    // 輸出結果\n    printf("Years: %d\\n", years);\n    printf("Weeks: %d\\n", weeks);\n    printf("Days: %d\\n", days);\n\n    return 0;\n}\n \n \n \n \n #include <stdio.h>\n\nint main() {\n    double wi1, ci1, wi2, ci2, result; // 宣告變數，用於存儲物品的重量和數量\n\n    // 提示用戶輸入物品1的重量\n    printf("Weight - Item1: ");\n    if (scanf("%lf", &wi1) != 1) {\n        fprintf(stderr, "Error: Invalid input for weight of item1.\\n");\n        return 1;\n    }\n\n    // 提示用戶輸入物品1的數量\n    printf("No. of item1: ");\n    if (scanf("%lf", &ci1) != 1) {\n        fprintf(stderr, "Error: Invalid input for count of item1.\\n");\n        return 1;\n    }\n\n    // 提示用戶輸入物品2的重量\n    printf("Weight - Item2: ");\n    if (scanf("%lf", &wi2) != 1) {\n        fprintf(stderr, "Error: Invalid input for weight of item2.\\n");\n        return 1;\n    }\n\n    // 提示用戶輸入物品2的數量\n    printf("No. of item2: ");\n    if (scanf("%lf", &ci2) != 1) {\n        fprintf(stderr, "Error: Invalid input for count of item2.\\n");\n        return 1;\n    }\n\n    // 計算平均值\n    result = ((wi1 * ci1) + (wi2 * ci2)) / (ci1 + ci2);\n\n    // 輸出平均值\n    printf("Average Value = %f\\n", result);\n\n    return 0;\n}\n \n \n \n \n \n \n', 'tags': '', 'url': '課程2.html'}, {'title': '練習2', 'text': '#include <stdio.h>\n\nint main() {\n    int x;    // 用於存儲總里程的變數，以公里為單位\n    float y;  // 用於存儲總耗油量的變數，以升為單位\n\n    // 提示用戶輸入總里程並存入 \'x\'\n    printf("Input total distance in km: ");\n    // 檢查 scanf 的返回值，確保成功讀取一個整數\n    if (scanf("%d", &x) != 1) {\n        fprintf(stderr, "Error: Invalid input for total distance.\\n");\n        return 1;\n    }\n\n    // 提示用戶輸入總耗油量並存入 \'y\'\n    printf("Input total fuel spent in liters: ");\n    // 檢查 scanf 的返回值，確保成功讀取一個浮點數\n    if (scanf("%f", &y) != 1) {\n        fprintf(stderr, "Error: Invalid input for total fuel spent.\\n");\n        return 1;\n    }\n\n    // 計算並打印平均油耗\n    printf("Average consumption (km/lt) %.3f ", x / y);\n    printf("\\n");\n\n    return 0;\n}\n \n \n #include <stdio.h>\n\nint main() {\n    float x, y, z, P; // 宣告變數，用於存儲三角形的邊長和周長\n\n    // 提示用戶輸入三個邊長並存入 \'x\', \'y\', 和 \'z\'\n    printf("\\nInput the first number: ");\n    if (scanf("%f", &x) != 1) {\n        fprintf(stderr, "Error: Invalid input for the first number.\\n");\n        return 1;\n    }\n\n    printf("\\nInput the second number: ");\n    if (scanf("%f", &y) != 1) {\n        fprintf(stderr, "Error: Invalid input for the second number.\\n");\n        return 1;\n    }\n\n    printf("\\nInput the third number: ");\n    if (scanf("%f", &z) != 1) {\n        fprintf(stderr, "Error: Invalid input for the third number.\\n");\n        return 1;\n    }\n\n    if (x < (y + z) && y < (x + z) && z < (y + x)) // 檢查是否可以構成三角形\n    {\n        P = x + y + z; // 計算周長\n        printf("\\nPerimeter  = %.1f\\n", P); // 輸出周長\n    } else {\n        printf("Not possible to create a triangle..!"); // 如果無法構成三角形，輸出相應的信息\n    }\n\n    return 0;\n}\n \n \n #include <stdio.h>\n\nint main() {\n    int j, numbers[5], total = 0; // 宣告數組用於存儲 5 個數字和變數用於總和\n\n    // 提示用戶輸入五個數字並存入數組\n    for (j = 0; j < 5; j++) {\n        printf("\\nInput the %s number: ", j == 0 ? "first" : (j == 1 ? "second" : (j == 2 ? "third" : (j == 3 ? "fourth" : "fifth"))));\n        if (scanf("%d", &numbers[j]) != 1) {\n            fprintf(stderr, "Error: Invalid input for the %s number.\\n", j == 0 ? "first" : (j == 1 ? "second" : (j == 2 ? "third" : (j == 3 ? "fourth" : "fifth"))));\n            return 1;\n        }\n    }\n\n    for (j = 0; j < 5; j++) {\n        if ((numbers[j] % 2) != 0) // 檢查數字是否為奇數\n        {\n            total += numbers[j]; // 將奇數添加到總和中\n        }\n    }\n\n    printf("\\nSum of all odd values: %d", total); // 輸出所有奇數的總和\n    return 0;\n}\n \n \n #include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint divide_two(int dividend_num, int divisor_num) {\n    int sign = (float)dividend_num / divisor_num > 0 ? 1 : -1;\n    unsigned int dvd = dividend_num > 0 ? dividend_num : -dividend_num;\n    unsigned int dvs = divisor_num > 0 ? divisor_num : -divisor_num;\n    unsigned int bit_num[33];\n    unsigned int i = 0;\n    long long d = dvs;\n\n    bit_num[i] = d;\n    while (d <= dvd) {\n        bit_num[++i] = d = d << 1;\n    }\n    i--;\n\n    unsigned int result = 0;\n    while (dvd >= dvs) {\n        if (dvd >= bit_num[i]) {\n            dvd -= bit_num[i];\n            result += (1 << i);\n        } else {\n            i--;\n        }\n    }\n\n    if (result > INT_MAX && sign > 0) {\n        return INT_MAX;\n    }\n    return (int)result * sign;\n}\n\nint main(void) {\n    int dividend_num = 15;\n    int divisor_num = 3;\n    printf("Quotient after dividing %d and %d: %d", dividend_num, divisor_num, divide_two(dividend_num, divisor_num));\n    return 0;\n}\n \n \n #include <stdio.h>\n\n// inline function to check if a given integer is even\ninline int is_even(int n) {\n    return n % 2 == 0;\n}\n\nint main() {\n    int num;\n\n    // 檢查 scanf 的返回值，確保成功讀取一個整數\n    if (scanf("%d", &num) != 1) {\n        fprintf(stderr, "Error: Invalid input. Please enter a valid integer.\\n");\n        return 1;\n    }\n\n    if (is_even(num)) {\n        printf("%d is even.\\n", num);\n    } else {\n        printf("%d is odd.\\n", num);\n    }\n\n    return 0;\n}\n \n \n #include <stdio.h>\n\n\ninline float celsius_To_Fahrenheit(float celsius) {\n  return (celsius * 9 / 5) + 32;\n}\ninline float fahrenheit_To_Celsius(float fahrenheit) {\n  return (fahrenheit - 32) * 5 / 9;\n}\n\nint main() {\n  float celsius = 40;\n  float fahrenheit = 89.60;\n  printf("%.2f Celsius is equal to %.2f Fahrenheit\\n", celsius, celsius_To_Fahrenheit(celsius));\n  printf("\\n%.2f Fahrenheit is equal to %.2f Celsius\\n", fahrenheit,\n    fahrenheit_To_Celsius(fahrenheit));\n  return 0;\n} \n \n #include <stdio.h>\n\nint main() {\n    int a, b;\n\n    // Prompt user for input\n    printf("Input two pairs values (integer values):\\n");\n\n    // Read two integer values from user and store them in \'a\' and \'b\'\n    if (scanf("%d %d", &a, &b) != 2) {\n        fprintf(stderr, "Error: Invalid input. Please enter two integer values.\\n");\n        return 1;  // Return an error code for invalid input\n    }\n\n    // Check if \'a\' is not equal to \'b\'\n    if (a != b) {\n        // Check if \'b\' is greater than \'a\'\n        if (b > a) {\n            printf("Ascending order\\n");  // Print message for ascending order\n        } else {\n            printf("Descending order\\n");  // Print message for descending order\n        }\n    }\n\n    return 0;  // End of program\n}\n \n \n #include <stdio.h>\n\nint main(void) {\n    unsigned char char1, char2, char3, char4, char5, char6, char7, char8;\n\n    // Print table header\n    printf("|---------------------------------------------------------------------------------------------------------|\\n");\n    printf("|extended ASCII table - excluding control characters                                                      |\\n");\n    printf("|   Ch Dec  Hex  |  Ch Dec  Hex   | Ch Dec  Hex | Ch Dec  Hex  | Ch Dec  Hex  | Ch Dec  Hex | Ch Dec  Hex |\\n");\n    printf("|----------------|----------------|-------------|--------------|--------------|-------------|-------------|\\n");\n\n    // Loop through characters\n    for (int i = 0; i < 32; i++) {\n        // Calculate characters for different ranges\n        char1 = i;\n        char2 = i + 32;\n        char3 = i + 64;\n        char4 = i + 96;\n        char5 = i + 128;  // extended ASCII characters\n        char6 = i + 160;\n        char7 = i + 192;\n        char8 = i + 224;\n\n        // Print characters and their decimal and hexadecimal representations\n        printf("|  %c %3d %#x ", char2, char2, char2);\n        printf("|  %c %3d %#x ", char3, char3, char3);\n\n        // Special case for DEL character\n        if (char4 == 127) {\n            printf("|%s %3d %#x |", "DEL", char4, char4);\n        } else {\n            printf("|  %c %3d %#x |", char4, char4, char4);\n        }\n\n        // Print extended ASCII characters for the current system.\n        printf("  %c %3d %#x |  %c %3d %#x |  %c %3d %#x |  %c %3d %#x |\\n",\n               char5, char5, char5,\n               char6, char6, char6,\n               char7, char7, char7,\n               char8, char8, char8);\n    }\n\n    return 0;  // Indicate successful execution of the program\n}\n \n \n #include <stdio.h>\n\nint main() {\n    int x; // Declare variable x\n\n    // Print header for the table\n    printf("x+1\\tx+3\\tx+5\\tx+7\\n\\n");\n    printf("---------------------------\\n");\n\n    // Loop to generate and print table values\n    for (x = 1; x <= 15; x += 3)\n        printf("%d\\t%d\\t%d\\t%d\\n", x, (x + 2), (x + 4), (x + 6));\n\n    return 0; // Indicate successful program execution\n}\n \n \n #include <stdio.h>\n\nint main() {\n    // 声明变量\n    float principal_amt, rate_of_interest, days, interest;\n    const int yearInDays = 365; // 用于转换利率的常量\n\n    // 提示用户输入贷款金额\n    printf("输入贷款金额 (输入 0 退出): ");\n    if (scanf("%f", &principal_amt) != 1) {\n        fprintf(stderr, "Error: Invalid input for loan amount.\\n");\n        return 1;\n    }\n\n    // 主循环用于处理贷款\n    while ((int)principal_amt != 0) \n    {\n        // 提示用户输入利率\n        printf("输入利率: ");\n        if (scanf("%f", &rate_of_interest) != 1) {\n            fprintf(stderr, "Error: Invalid input for interest rate.\\n");\n            return 1;\n        }\n\n        // 提示用户输入贷款期限（天）\n        printf("输入贷款期限（天）: ");\n        if (scanf("%f", &days) != 1) {\n            fprintf(stderr, "Error: Invalid input for loan term.\\n");\n            return 1;\n        }\n\n        // 计算利息\n        interest = (principal_amt * rate_of_interest * days) / yearInDays;\n\n        // 显示利息金额\n        printf("利息金额为 $%.2f\\n", interest);\n\n        // 提示用户输入下一个贷款金额\n        printf("\\n\\n输入贷款金额 (输入 0 退出): ");\n        if (scanf("%f", &principal_amt) != 1) {\n            fprintf(stderr, "Error: Invalid input for loan amount.\\n");\n            return 1;\n        }\n    }\n\n    return 0;\n}\n \n \n', 'tags': '', 'url': '練習2.html'}, {'title': '期末總結', 'text': '我覺得我的得分應該有80分，雖然一開始我對這個課程感到絕望也一度放棄，但後面我有想努力通過，我還會熬夜做出來，而且有一次還做到早上7.才做完它讓我很崩潰，但我還是努力做完它了，所以這是我期望的分數，希望可以通過這個科目。 \n A: 是否 按照進度明確標示倉儲的改版歷程。是的我有。 \n B: 是否根據\xa0IPv4 與 IPv6\xa0網路環境設定進行作法討論 \n \n \n C: 是否就\xa0Replit、s.cycu.org 與 localhost\xa0情境下對個人與分組倉儲進行設定操作 \n \n \n D: 是否完成 上課內容 中的 Exercises 是的，但是第九周的內容我不太會做 \n E: 是否完成\xa0 w2-w5 \xa0 週任務中的 Exercises。有我有做出來放在個人網站。 \n F: 是否完成\xa0 w6-w7 \xa0 週任務中的練習一與練習二。有我有做出來放在個人網站。 \n G: 是否完成 C 結合 gd 繪圖程式庫, 畫出\xa0 PROC ( 規格 ), \xa0 United Kingdom ( 規格 ), \xa0 Japan ( 規格 )與 \xa0 South Korea ( 規格 ) Flags。有我有做出來放在個人網站。 \n H: 是否完成 w16 Final Project。有我有做出來放在個人網站。 \n 布萊頓 \n https://en.wikipedia.org/wiki/Python_（程式語言） \n 例子： \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python教學： \n https://docs.python.org/3/tutorial/ \n Python的平衡介紹 \n 縮排（Python採用4個Spaces縮排，以介面執行範圍） \n 變數（ Python 關鍵字 ） \n 註（#單行註解、三單標註或三雙標註標註多行註解） \n 數 (整數 int(), 浮點數 float()) \n 字串 （字符串） \n print (Python 內建函數,  print() 函數式) \n Python是控制流程工具 \n 為了 \n 如果 \n 範圍 \n 開放 \n 讀 \n 清單 \n 元組 \n 字典 \n 功能 \n 嘗試...除了 \n 休息時間 \n 曾經 \n 類別 \n 此頁面示範如何在同一頁面下加入多個線上Ace編輯器與執行按鈕（ practice_html.txt 動態頁面超檔案）。 \n Practice_html.txt 動態頁面超檔案應該可以在啟動Brython時，設定分割.py檔案放入downloads/py目錄中的參考。 \n 也所有出現的反html也使用Brython產生，編寫成 類別 後，在範例匯入時交叉< ai=3>實例 引用。 \n \n<腳本> \n視窗.onload=函數(){ \nbrython({ 調試:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']}); \n} \n</> 腳本 \n 從1累加到100： \n 1加到100 \n 將iterable與iterator 相關說明 ，利用Brython與Ace Editor整理頁面。 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n 文件名稱： .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n 跑步   輸出   明確輸出區 清晰的繪圖區 重新載入 \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從1累加到100第2部分： \n 1加到100 cango_三_齒輪 BS蛇 人工智慧俄羅斯區塊鏈 旋轉塊 \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n 文件名稱： .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n 跑步   輸出   明確輸出區 清晰的繪圖區 重新載入 \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n', 'tags': '', 'url': '期末總結.html'}]};