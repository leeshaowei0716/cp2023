var tipuesearch = {"pages": [{'title': '關於', 'text': 'https://github.com/mdecycu/cmsite \n', 'tags': '', 'url': '關於.html'}, {'title': 'w6', 'text': '// 包含標準輸出入程式庫的標頭檔 // https://blog.csdn.net/weixin_38468077/article/details/101069365< ai=2>// http://www.gnuplot.info/demo/  // https:// /https:// /https:// /https:///github 。com/sysprog21/rv32emu  // https://github.com/sysprog21/semu  // https://docs.  google.com/presentation / d/14N0cWG2SnBSqhc2cLF0_2VerB9FF8JN3  // https://cs61c .org/fa23/  // https://greenteapress.com/wp/think-python-2e /  // https://github.com/ecalvub. .com/ecalvadi /c99-examples  // https://github.com/gouravthakur39/初學者- C -program -examples  // https://github.com/ergenekonyigit/Numerical-Analysis-Examples  // https:/ /https: //github.com/ergenekonyigit/Numerical-Analysis-Examples /www.che  .ncku .edu.tw /facultyweb/changct/ html/teaching/CPPandMATLAB/ Past/pdf%20Files /Chap02-Ling.pdf  // https://gteceducation.com.com.com/ Brochures /PROGRAMMING/ C%20PROGRAMMING%20PROGRAMMING%20FULL .pdf  // https://sg.pdf // https://sg/jsommers.github。io/cbook/ cbook.  pdf  // https://jsomers.github.io/cbook/index.html  // http://student.itee .uq .edu.au/courses/csse2310/CProgrammingNotes.pdf  // http://cslibrary.stanford .edu/101/ EssentialC.pdf  // https://publications.gbdirect.co.uk/c_book/  // https://www.fossil-scm.org/fossil-book/doc/ 2ndEdition/fossilbook.pdf< /a >  // cc gnuplot_ex1.c -o gnuplot_ex1< /a >  #include  // ./gnuplot_ex1  // cd下載 // **** * 在replit執行 \xa0 \n //\xa0  int main() {  //popen 啟動 Gnuplot 程式 FILE *gnuplotPipe = popen("gnuplot -persistent", "w");  if (!gnuplotPipe) {  fprintf(stderr, "啟動Gnuplot失敗。\\n" ;) ; 回傳1； } \n // 使用 G  pclose(gnuplotPipe); \n 返回0;  } \n \xa0 \n', 'tags': '', 'url': 'w6.html'}, {'title': 'w7', 'text': '\n // https://en.wikipedia.org/wiki/Flag_of_thcp2023.a0968899313.repl.coe_Republic_of_China \n// cc roc_flag.c -lgd -lm 連接gd與數學庫 \n// https://www.rapidtables.com/web/color/RGB_Color.html \n// 幾何形狀著色與繪圖練習 \n//以下gd繪畫教學嘗試類似的中華民國國旗，請根據以下計劃內容完成後續的國旗綁定 \n＃包括 \n＃包括 \n#包括 \n \nvoiddraw_roc_flag（gdImagePtr img）； \nvoid draw_white_sun(gdImagePtr img, int x, int y, int size, int color); \n \nint main() { \n//寬度3:高度2 \n整數寬度=1200； \nint 高度 = (int)(寬度*2.0 / 3.0); \n \ngdImagePtr img = gdImageCreateTrueColor(寬度, 高度); \ngdImageAlphaBlending(img, 0); \n \n鄰近_roc_flag（img）； \n \nFILE *outputFile = fopen("./../images/roc_flag.png", "wb"); \n如果（輸出檔== NULL）{ \nfprintf(stderr, "開啟輸出檔時發生錯誤。\\n"); \n回傳1； \ngdImagePngEx \n(img, 輸出檔, 9); \nfclose(輸出檔); \ngdImageDestroy(img); \n回傳0； \n} \n \ndrawroVinc_flag（gdImagePtr img）{ \nint寬度= gdImageSX（img）; \nint 高度 = gdImageSY(img); \nint 紅、白、藍； \nint center_x = (int)(寬度/4); \nint center_y = (int)(高度/4); \nint sun_radius = (int)(寬度/8); \n// 標誌顏色 \n紅色 = gdImageColorAllocate(img, 242, 0, 0);  // \n紅白 = gdImageColorAllocate(img, 255, 255, 255);  // 白色條紋 \n藍色 = gdImageColorAllocate(img, 0, 41, 204);  // 藍色 \n// 紅色自訂區域 \ngdImageFilledRectangle(img, 0, 0, 寬度, 高度, 紅色); \n// 藍色區域 \ngdImageFilledRectangle(img, 0, 0, (int)(寬度/2.0), (int)(高度/2.0), 藍色); \n//目前只出青天白日的直線，請嘗試計算所需的點座標完成國旗繪圖 \ndraw_white_sun(img, center_x, center_y, sun_radius, 白色); \n} \n \nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int color) { \n浮動角度 = 0; \nint fromX, fromY; \nint toX, toY; \nfor (int i=0; i<24; i++){ \n角度+= 5*M_PI*2/12; \n//printf("%.3f", 角度); \ntoX = center_x + cos(角度)*sun_radius; \ntoY = center_y + sin(角度)*sun_radius; \n// 允許i為0時移動到toX, toY，其餘都進行直線起重機 \n如果（我！=0）{ \ngdImageLine(img, fromX, fromY, toX, toY, 顏色); \n} \n從X = 到X; \n從Y = 到Y； \n} \n} \n \n \n \n ＃包括 \n＃包括 \n＃包括 \n \n無效draw_usa_flag（gdImagePtr img）； \nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double spin_angle); \n \nint main() { \n    整數寬度=800； \n    int 高度 = (int)(寬度 / 1.9); \n \n    gdImagePtr img = gdImageCreateTrueColor(寬度, 高度); \n    gdImageAlphaBlending(img, 0); \n \n    各地_美國_標誌（img）； \n \n    FILE *outputFile = fopen("./../images/usa_flag.png", "wb"); \n    如果（輸出檔== NULL）{ \n        fprintf(stderr, "開啟輸出檔時發生錯誤。\\n"); \n        返回1； \n    } \n \n    gdImagePngEx(img, 輸出檔, 9); \n    fclose(輸出檔); \n    gdImageDestroy(img); \n \n    返回0； \n} \n \n無效draw_usa_flag（gdImagePtr img）{ \n    int 寬度 = gdImageSX(img); \n    int 高度 = gdImageSY(img); \n    int 紅、白、藍； \n    // 國旗顏色 \n    紅色 = gdImageColorAllocate(img, 178, 34, 52);  // 紅色條紋 \n    白色 = gdImageColorAllocate(img, 255, 255, 255);  // 白色條紋 \n    藍色 = gdImageColorAllocate(img, 60, 59, 110);  // 藍色 \n \n    int stripe_height = 高度 / 13; \n    int stripe_width = 寬度； \n    int star_size = (int)(0.0308 * 高度);  // 星星大小 \n \n    for (int y = 0; y < 高度; y += stripe_height) { \n        if (y / stripe_height % 2 == 0) { \n            gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, 紅色); \n        }另外{ \n            gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, 白色); \n        } \n    } \n \n    gdImageFilledRectangle(img, 0, 0, 寬度 * 2 / 5, stripe_height * 7, 藍色); \n \n    int star_spacing_x = (int)(0.129 * 高度);  //橫向之間的距離 \n    int star_spacing_y = (int)(0.054 * 高度);  //縱向星星之間的距離 \n    int star_start_x = (int)(0.125 * 高度);  // 星星的起始X位置 \n    int star_start_y = (int)(0.0485 * 高度);  // 最開始的Y位置 \n \n    for (int row = 0; row < 9; row++) { \n        int starPerRow = (行 % 2 == 0) ?  6：5； \n \n        // 計算2、4、6和8排星星的偏移量 \n        int offset_x = (行 % 2 == 0) ?  star_spacing_x / -2 : 0; \n \n        for (int 星號 = 0; 星號 \n            int x = star_start_x + star * star_spacing_x + offset_x; \n \n            // 旋轉角度（以弧度為單位） \n            雙旋轉角度 = M_PI / 5;  // 忘記旋轉多少度 \n \n            int y = star_start_y + 行 * star_spacing_y; \n            draw_star(img, x, y, star_size, 白色, 旋轉角度); \n        } \n    } \n} \n \nvoid draw_star(gdImagePtr img, int x, int y, int 大小, int 顏色, 雙rotation_angle) { \n    gdPoint點[10]； \n \n    for (int i = 0; i < 10; i++) { \n        雙倍角度 = M_PI / 2 + i * 2 * M_PI / 10 + 旋轉角度； \n        int 半徑 = (i % 2 == 0) ?尺寸：尺寸/2； \n        點[i].x = x + 半徑 * cos(角); \n        點[i].y = y + 半徑 * sin(角); \n    } \n \n    // 使用指定的顏色填滿星星 \n    gdImageFilledPolygon(img, 點, 10, 顏色); \n} \n \n \n \n \n \n', 'tags': '', 'url': 'w7.html'}, {'title': 'w8', 'text': '＃包括 \n＃包括 \n＃包括 \n \n實際上無效JapanFlag() { \n整數寬度=300； // 寬度 \n整數=高度200； // 高度 \n半徑=50； // 貨物半徑 \nint 中心X = 150;  // 交易中心X座標 \nint 中心Y = 100;  // 訂單中心Y座標 \n \n// 建立一張24元的彩色圖片 \ngdImagePtr im = gdImageCreateTrueColor(寬度, 高度); \n \n// 設定背景色為白色 \nint 白色 = gdImageColorAllocate(im, 255, 255, 255); \ngdImageFill(im, 0, 0, 白色); \n \n// 設定需求的顏色為紅色 \nint 紅色 = gdImageColorAllocate(im, 255, 0, 0); \n \n// 畫紅色浪漫 \ngdImageFilledEllipse(im, centerX, centerY, 2 * 半徑, 2 * 半徑, 紅色); \n \n//輸出圖片到文件 \n檔 *output = fopen("japanese_flag.png", "wb"); \n如果（輸出== NULL）{ \nfprintf(stderr, "無法開啟檔案寫入。\\n"); \n退出（EXIT_FAILURE）； \n} \n \ngdImagePng(im, 輸出); \n \n// 釋放記憶體 \ngdImageDestroy(im); \nfclose(輸出); \n} \n \nint main() { \n鄰近日本國旗(); \nprintf("創建日本國旗：japanese_flag.png\\n"); \n返回0； \n} \n \n \n \n \n ＃包括 \n＃包括 \n＃包括 \n \nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double spin_angle); \n無效draw_chinese_flag(gdImagePtr img); \n \nint main() { \n整數寬度=300； // 國旗寬度 \n整數高度=200； // 國旗高度 \n \ngdImagePtr im = gdImageCreateTrueColor(寬度, 高度); \ngdImageAlphaBlending(im, 0); \n \n鄰近中文標誌（im）； \n \nFILE *outputFile = fopen("./../images/proc_flag.png", "wb"); \n如果（輸出檔== NULL）{ \nfprintf(stderr, "開啟輸出檔時發生錯誤。\\n"); \n返回1； \n} \n \ngdImagePngEx(im, 輸出檔, 9); \nfclose(輸出檔); \ngdImageDestroy(im); \n \n返回0； \n} \n \nvoid draw_star(gdImagePtr img, int x, int y, int 大小, int 顏色, 雙rotation_angle) { \ngdPoint點[10]； \n \n雙外半徑=大小/2； \n雙內半徑=大小/6； \n雙倍角度 = M_PI / 5.0； \n \nfor (int i = 0; i < 10; i++) { \n雙半徑 = (i % 2 == 0) ?外半徑：內半徑； \n雙 theta = 旋轉角度 + i * 角度； \n點[i].x = x + 半徑 * cos(theta); \n點[i].y = y + 半徑 * sin(theta); \n} \n \ngdImageFilledPolygon(img, 點, 10, 顏色); \n} \n \ndraw_chinese_flag（gdImagePtr img）{ \nint 寬度 = gdImageSX(img); \nint 高度 = gdImageSY(img); \nint紅色、黃色； \n \n紅色 = gdImageColorAllocate(img, 255, 0, 0);  // 紅色背景 \n黃色 = gdImageColorAllocate(img, 255, 255, 0);  // 黃色星星 \n \ngdImageFilledRectangle(img, 0, 0, 寬度, 高度, 紅色); \n \nint star_size = (int)(0.28 * 高度); \nint star_x = (int)(0.165 * 寬度); \nint star_y = (int)(0.265 * 高度); \n \ndraw_star(img, star_x, star_y, star_size, 黃色, 11.0); \n \n雙半徑=0.15*高度； \n雙倍角度 = 360 / 7 * M_PI / 179.0； \n雙旋轉 = -M_PI / 7.5； \nint cx = (int)(0.32 * 寬度); \nint cy = (int)(0.27 * 高度); \n \nfor (int i = -1; i < 3; i++) { \nint x = (int)(cx + 半徑 * cos(i * 角度 + 旋轉)); \nint y = (int)(cy + 半徑 * sin(i * 角度 + 旋轉)); \ndraw_star(img, x, y, 19, 黃色, M_PI / 5.0); \n} \n} \n \n \n \n ＃包括 \n＃包括 \n＃包括 \n \n無效draw_uk_flag（gdImagePtr img）； \nvoid fillTriangle(gdImagePtr img, int x1, int y1, int x2, int y2, int x3, int y3, int color); \n \nint main() { \n整數寬度=1200； \nint 高度 = 寬度 / 2; \n \ngdImagePtr img = gdImageCreateTrueColor(寬度, 高度); \ngdImageAlphaBlending(img, 0); \n \n各地_英國_標誌（img）； \n \nFILE *outputFile = fopen("./../images/uk_flag.png", "wb"); \n如果（輸出檔== NULL）{ \nfprintf(stderr, "開啟輸出檔時發生錯誤。\\n"); \n返回1； \n} \n \ngdImagePngEx(img, 輸出檔, 9); \nfclose(輸出檔); \ngdImageDestroy(img); \n \n返回0； \n} \n \n無效draw_uk_flag（gdImagePtr img）{ \nint 寬度 = gdImageSX(img); \nint 高度 = gdImageSY(img); \n \nint 紅、白、藍； \n紅色 = gdImageColorAllocate(img, 204, 0, 0); \n白色 = gdImageColorAllocate(img, 255, 255, 255); \n藍色 = gdImageColorAllocate(img, 0, 0, 153); \n \ngdImageFilledRectangle(img, 0, 0, 寬度, 高度, 藍色); \n \n// 勢弱斜線 \n{ \nint 線粗度 = 100; \ngdImageSetThickness(img, line_thickness); \n \n// 鄰近白色斜線 \nint x1 = 0，y1 = 600，x2 = 1200，y2 = 0； \ngdImageLine(img, x1, y1, x2, y2, 白色); \n \nx1 = 0，y1 = 0，x2 = 1200，y2 = 600； \ngdImageLine(img, x1, y1, x2, y2, 白色); \n} \n \n// 各地紅色斜線 \n{ \nint 線粗度 = 33; \ngdImageSetThickness(img, line_thickness); \n \n// 各地紅色斜線 \n整數 x1 = 566，y1 = 300，x2 = 1166，y2 = 0； \ngdImageLine(img, x1, y1, x2, y2, 紅色); \n \nx1 = 1233，y1 = 600，x2 = 633，y2 = 300； \ngdImageLine(img, x1, y1, x2, y2, 紅色); \n \nx1 = 566，y1 = 300，x2 = -33，y2 = 0； \ngdImageLine(img, x1, y1, x2, y2, 紅色); \n \nx1 = 600，y1 = 316.5，x2 = 0，y2 = 616.5； \ngdImageLine(img, x1, y1, x2, y2, 紅色); \n} \n \n// 鄰近白色斜線 \n{ \nint 線粗度 = 33; \ngdImageSetThickness(img, line_thickness); \n \n// 勢弱斜線 \nint x1 = 0，y1 = 600，x2 = 1200，y2 = 0； \ngdImageLine(img, x1, y1, x2, y2, 紅色); \n \nx1 = 1200，y1 = 16.5，x2 = 600，y2 = 316.5； \ngdImageLine(img, x1, y1, x2, y2, 白色); \n \nx1 = 0，y1 = 583.5，x2 = 600，y2 = 283.5； \ngdImageLine(img, x1, y1, x2, y2, 白色); \n} \n \n// 不平等白色十字 \nint cross_width = 寬度 / 32; \nint cross_arm_width = 寬度 / 32; \nint center_x = 寬度 / 2; \nint center_y = 高度 / 2; \n \ngdImageFilledRectangle(img, center_x + 2.7 * cross_width, 0, center_x - 2.7 * cross_width, 高度, 白色); \ngdImageFilledRectangle(img, 0, center_y + 2.7 * cross_arm_width, 寬度, center_y - 2.7 * cross_arm_width, 白色); \n \n// 各地紅色十字 \ngdImageFilledRectangle(img, center_x + 1.5 * cross_width, 0, center_x - 1.5 * cross_width, height, red); \ngdImageFilledRectangle(img, 0, center_y + 1.5 * cross_arm_width, 寬度, center_y - 1.5 * cross_arm_width, 紅色); \n} \n \n \n \n ＃包括 \n＃包括 \n \nint main() { \n    // 建立一個新的GD圖片（法國國旗尺寸：900x600） \n    gdImagePtr im = gdImageCreateTrueColor(900, 600); \n \n    // 定義顏色（RGB格式） \n    int 藍色 = gdImageColorAllocate(im, 0, 0, 255); \n    int 白色 = gdImageColorAllocate(im, 255, 255, 255); \n    int 紅色 = gdImageColorAllocate(im, 255, 0, 0); \n \n    // 縱向條紋（3等寬） \n    int 條帶寬度 = 900 / 3; \n    gdImageFilledRectangle(im, 0, 0, stripeWidth - 1, 599, 藍色); \n    gdImageFilledRectangle(im, stripeWidth, 0, 2 * stripeWidth - 1, 599, 白色); \n    gdImageFilledRectangle(im, 2 * stripeWidth, 0, 899, 599, 紅色); \n \n    // 將圖片儲存到檔案中 \n    FILE *outputFile = fopen(“french_flag.png”, “wb”); \n    gdImagePng(im, 輸出檔); \n    fclose(輸出檔); \n \n    // 釋放GD影像 \n    gdImageDestroy(im); \n \n    返回0； \n} \n \n \n #include <gd.h> \n#include <stdio.h> \n#include <數學.h> \n \nint main() { \n    gdImagePtr im； \n    文件*輸出； \n    int 白色、紅色、藍色、黑色； \n \n    im = gdImageCreateTrueColor(600, 400); \n    白色 = gdImageColorAllocate(im, 255, 255, 255); \n    紅色 = gdImageColorAllocate(im, 225, 0, 0); \n    藍色 = gdImageColorAllocate(im, 0, 0, 225); \n    黑色 = gdImageColorAllocate(im, 0, 0, 0); \n \n    // 填滿白色背景 \n    gdImageFilledRectangle(im, 0, 0, 599, 399, 白色); \n \n    // 在中間加入紅藍色各一半的圓，將紅色移到上方，藍色移到下方 \n    int 中心X = 300; \n    int 中心Y = 200; \n    整數半徑=200； \n \n    gdImageFilledArc(im, centerX, centerY, 半徑, 半徑, 0, 180, 藍色, gdPie); \n    gdImageFilledArc(im, centerX, centerY - 1, 半徑, 半徑, 180, 360, 紅色, gdPie); \n \n    // 在中間加入右側偏移49的直徑為100的藍色圓 \n    int 藍色圓半徑 = 50;  // 半徑為50 \n    int offsetX = 49； \n    gdImageFilledEllipse(im, centerX + offsetX, centerY, blueCircleRadius * 2, blueCircleRadius * 2, 藍色); \n \n    // 在中間加入向左偏移50的直徑為100的紅色圓 \n    int 紅色圓半徑 = 50;  // 半徑為50 \n    gdImageFilledEllipse(im, centerX - 49, centerY, redCircleRadius * 2, redCircleRadius * 2, 紅色); \n \n    // 將中間的圖形順時針旋轉104度 \n    雙角 = 104.0； \n    gdImagePtr 旋轉_im = gdImageCreateTrueColor(600, 400); \n    gdImageFilledRectangle(rotated_im, 0, 0, 599, 399, 白色); \n \n    // 複製原始影像 \n    gdImageCopy(rotated_im, im, 0, 0, 0, 0, 600, 400); \n \n    // 逆時針旋轉的角度 \n    雙旋轉角度 = 25.0; \n \n    // 相對斜直的長方形 \n    int 矩形寬度 = 15;  // 長方形寬度 \n    int 矩形高度 = 120;  // 長方形高度 \n    int 矩形間距 = 10;  // 長方形間隔 \n \n    // 計算三個長方形的左上角座標 \n    int rect1X = 139 - 矩形寬度 - 矩形間距； // 第一個長方形 \n    int 矩形1Y = 206 - 矩形高度/2； \n    int 矩形2X = 矩形1X - 矩形寬度 - 矩形間距； // 第二個長方形 \n    int 矩形2Y = 矩形1Y； \n    int 矩形3X = 矩形2X - 矩形寬度 - 矩形間距； // 第三個長方形 \n    int 矩形3Y = 矩形1Y； \n \n    gdPoint點1[4]； \n    點1[0].x = (int)(rect1X - centerX) * cos(rotationAngle * M_PI / 180) - (rect1Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n    點1[0].y = (int)(rect1X - centerX) * sin(rotationAngle * M_PI / 180) + (rect1Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n    點1[1].x = (int)((矩形1X + 矩形寬度) - centerX) * cos(旋轉角度* M_PI / 180) - (矩形1Y - centerY) * sin(旋轉角度* M_PI / 180) + centerX; \n    點1[1].y = (int)((矩形1X + 矩形寬度) - centerX) * sin(旋轉角度* M_PI / 180) + (矩形1Y - centerY) * cos(旋轉角度* M_PI / 180) + centerY; \n    點1[2].x = (int)((矩形1X + 矩形寬度) - centerX) * cos(旋轉角度* M_PI / 180) - ((矩形1Y + 矩形高度) - centerY) * sin(旋轉角度* M_PI / 180) + centerX; \n    點1[2].y = (int)((矩形1X + 矩形寬度) - centerX) * sin(旋轉角度* M_PI / 180) + ((矩形1Y + 矩形高度) - centerY) * cos(旋轉角度* M_PI / 180) + centerY; \n    點1[3].x = (int)(矩形1X - 中心X) * cos(旋轉角度* M_PI / 180) - ((矩形1Y + 矩形高度) - 中心Y) * sin(旋轉角度* M_PI / 180 ) + centerX; \n    點1[3].y = (int)(矩形1X - 中心X) * sin(旋轉角度* M_PI / 180) + ((矩形1Y + 矩形高度) - 中心Y) * cos(旋轉角度* M_PI / 180 ) + centerY; \n \n    gdPoint點2[4]； \n    點2[0].x = (int)(rect2X - centerX) * cos(rotationAngle * M_PI / 180) - (rect2Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n    點2[0].y = (int)(rect2X - centerX) * sin(rotationAngle * M_PI / 180) + (rect2Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n    點2[1].x = (int)((矩形2X + 矩形寬度) - centerX) * cos(rotationAngle * M_PI / 180) - (矩形2Y - centerY) * sin(旋轉角度* M_PI / 180) + centerX ; \n    點2[1].y = (int)((矩形2X + 矩形寬度) - centerX) * sin(旋轉角度* M_PI / 180) + (矩形2Y - centerY) * cos(旋轉角度* M_PI / 180) + centerY; \n    點2[2].x = (int)((矩形2X + 矩形寬度) - centerX) * cos(旋轉角度* M_PI / 180) - ((矩形2Y + 矩形高度) - centerY) * sin(旋轉角度* M_PI / 180) + centerX; \n    點2[2].y = (int)((矩形2X + 矩形寬度) - centerX) * sin(旋轉角度* M_PI / 180) + ((矩形2Y + 矩形高度) - centerY) * cos(旋轉角度* M_PI / 180) + centerY; \n    點2[3].x = (int)(rect2X - centerX) * cos(rotationAngle * M_PI / 180) - ((rect2Y + rectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n    點2[3].y = (int)(rect2X - centerX) * sin(rotationAngle * M_PI / 180) + ((rect2Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n    gdPoint點3[4]； \n    點3[0].x = (int)(rect3X - centerX) * cos(rotationAngle * M_PI / 180) - (rect3Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n    點3[0].y = (int)(rect3X - centerX) * sin(rotationAngle * M_PI / 180) + (rect3Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n    點3[1].x = (int)((rect3X + rectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - (rect3Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n    點3[1].y = (int)((rect3X + rectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + (rect3Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n    點3[2].x = (int)((矩形3X + 矩形寬度) - centerX) * cos(旋轉角度* M_PI / 180) - ((矩形3Y + 矩形高度) - centerY) * sin(旋轉角度* M_PI / 180) + centerX; \n    點3[2].y = (int)((rect3X + rectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect3Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + center ; \n    點3[3].x = (int)(rect3X - centerX) * cos(rotationAngle * M_PI / 180) - ((rect3Y + rectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n    點3[3].y = (int)(rect3X - centerX) * sin(rotationAngle * M_PI / 180) + ((rect3Y + rectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n    gdImageFilledPolygon(rotated_im, 點1, 4, 黑色); \n    gdImageFilledPolygon（rotated_im，points2，4，黑色）； \n    gdImageFilledPolygon(rotated_im, 點3, 4, 黑色); \n \n \n  {//新增的黑色斜形 \n  gdPoint rect4Points[4]; \n  int rect4X = 70;  // 第四個長方形 \n  int rect4Y = 185; \n  rect4Points[0].x = (int)(rect4X - centerX) * cos(rotationAngle * M_PI / 180) + (rect4Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4Points[0].y = (int)(rect4X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  int 矩形寬度 = 矩形寬度； // 假設 rectWidth 已經定義 \n  int rect4Height = rectHeight;  // 假設 rectHeight 已經定義 \n  rect4Points[1].x = (int)((rect4X + rect4Width) - centerX) * cos(rotationAngle * M_PI / 180) + (rect4Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4Points[1].y = (int)((rect4X + rect4Width) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  矩形點[2].x = (int)((矩形寬度+ 矩形寬度) - centerX) * cos(旋轉角度* M_PI / 180) + ((矩形Y + 矩形高度) - centerY) * sin(旋轉角度* M_PI / 180) + centerX; \n  矩形點[2].y = (int)((矩形X + 矩形寬度) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((矩形Y + 矩形高度) - centerY) * cos(旋轉角* M_PI / 180) + 中心Y； \n  rect4Points[3].x = (int)(rect4X - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4Y + rect4Height) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  矩形點[3].y = (int)(矩形X - 中心X) * (-sin(旋轉角度* M_PI / 180)) + ((矩形Y + 矩形高度) - 中心Y) * cos(旋轉角度* M_PI / 180) + 中心Y; \n \n  gdImageFilledPolygon(rotated_im, rect4Points, 4, 黑色); \n \n  // 修改第五個斜形 \n  gdPoint rect5Points[4]; \n  int 矩形5X = 矩形4X + 矩形4寬度 + 矩形間距； // 第五個長方形 \n  int 矩形5Y = 矩形4Y； \n  int 中間矩形寬度 = 15;  // 中間長方形寬度 \n  int 中間矩形高度 = 55;  // 中間長方形高度 \n  int 中間矩形間距 = 10;  // 中間長方形兩邊間隔 \n  rect5Points[0].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) + (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect5Points[0].y = (int)(rect5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect5Points[1].x = (int)((rect5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) + (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect5Points[1].y = (int)((rect5X + middleRectWidth) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  矩形點[2].x = (int)((矩形矩形寬度) - centerX) * cos(旋轉角度* M_PI / 180) + ((矩形矩形高度+ 矩形高度) - centerY) * sin(旋轉角度* M_PI / 180) + centerX; \n  矩形點[2].y = (int)((矩形矩形寬度+ 矩形寬度) - 中心X) * (-sin(旋轉角度* M_PI / 180)) + ((矩形矩形高度+ 矩形高度) - 中心Y ) * cos(旋轉角度* M_PI / 180) + 中心Y； \n  rect5Points[3].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) + ((rect5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect5Points[3].y = (int)(rect5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rect5Points, 4, 黑色); \n \n  //新增位於第五個斜形下方的新的黑色斜形 \n  gdPoint rectBelow5Points[4]; \n  int rectBelow5X = rect5X; \n  int 矩形下方5Y = 矩形5Y + 中間矩形高度 + 中間矩形間距； \n  rectBelow5Points[0].x = (int)(rectBelow5X - centerX) * cos(rotationAngle * M_PI / 180) + (rectBelow5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rectBelow5Points[0].y = (int)(rectBelow5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rectBelow5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rectBelow5Points[1].x = (int)((rectBelow5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) + (rectBelow5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rectBelow5Points[1].y = (int)((rectBelow5X + middleRectWidth) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rectBelow5Y - centerY) * cos(rotationAngle * M_PI / 180) + +PI; \n  rectBelow5Points[2].x = (int)((rectBelow5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) + ((rectBelow5Y + middleRectHeight) - centerY) * sin(rotationAngle * MPIPIY + middleRectHeight) - centerY) * sin(rotationAngle * MPIPI +/Xenter \n  rectBelow5Points[2].y = (int)((rectBelow5X + middleRectWidth) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rectBelow5Y + middleRectHeight) - centerY) * cos(rotation 180PI_PI) + 中心Y； \n  rectBelow5Points[3].x = (int)(rectBelow5X - centerX) * cos(rotationAngle * M_PI / 180) + ((rectBelow5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rectBelow5Points[3].y = (int)(rectBelow5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rectBelow5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + center; \n \n  gdImageFilledPolygon(rotated_im, rectBelow5Points, 4, 黑色); \n \n  //新增新的黑色斜形 \n  gdPoint rect6Points[4]; \n  int 矩形6X = 矩形5X + 中間矩形寬度 + 矩形間距； // 第六個長方形 \n  int 矩形6Y = 矩形4Y； \n  rect6Points[0].x = (int)(rect6X - centerX) * cos(rotationAngle * M_PI / 180) + (rect6Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6Points[0].y = (int)(rect6X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  int 矩形寬度=矩形寬度； // 假設 rectWidth 已經定義 \n  int rect6Height = rectHeight;  // 假設 rectHeight 已經定義 \n  rect6Points[1].x = (int)((rect6X + rect6Width) - centerX) * cos(rotationAngle * M_PI / 180) + (rect6Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  矩形點[1].y = (int)((矩形X + 矩形寬度) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (矩形6Y - centerY) * cos(旋轉角度* M_PI / 180 ) + centerY; \n  矩形點[2].x = (int)((矩形寬度+ 矩形寬度) - centerX) * cos(旋轉角度* M_PI / 180) + ((矩形Y + 矩形高度) - centerY) * sin(旋轉角度* M_PI / 180) + centerX; \n  矩形點[2].y = (int)((矩形X + 矩形寬度) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((矩形Y + 矩形高度) - centerY) * cos(旋轉角* M_PI / 180) + 中心Y； \n  rect6Points[3].x = (int)(rect6X - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6Y + rect6Height) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  矩形點[3].y = (int)(矩形X - 中心X) * (-sin(旋轉角度* M_PI / 180)) + ((矩形Y + 矩形高度) - 中心Y) * cos(旋轉角度* M_PI / 180) + 中心Y; \n \n  gdImageFilledPolygon(rotated_im, rect6Points, 4, 黑色);} \n \n  {//增加新的黑色斜形（第四個，上半部） \n  gdPoint rect4aPoints[4]; \n  int rect4aX = 460;  // 第四個長方形（上半部） \n  int rect4aY = 139; \n  rect4aPoints[0].x = (int)(rect4aX - centerX) * cos(rotationAngle * M_PI / 180) + (rect4aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4aPoints[0].y = (int)(rect4aX - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect4aPoints[1].x = (int)((rect4aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect4aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4aPoints[1].y = (int)((rect4aX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect4aPoints[2].x = (int)((rect4aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4aPoints[2].y = (int)((rect4aX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + 中心Y； \n  rect4aPoints[3].x = (int)(rect4aX - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4aPoints[3].y = (int)(rect4aX - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rect4aPoints, 4, 黑色); \n \n  //新增新的黑色斜形（第四個，下半部） \n  gdPoint rect4bPoints[4]; \n  int rect4bX = 460;  // 第四個長方形（下半部） \n  int rect4bY = 139 + 55 + 10； // 上半部的 Y 座標 + 上半部的高度 + 間隔 \n  rect4bPoints[0].x = (int)(rect4bX - centerX) * cos(rotationAngle * M_PI / 180) + (rect4bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4bPoints[0].y = (int)(rect4bX - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect4bPoints[1].x = (int)((rect4bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect4bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4bPoints[1].y = (int)((rect4bX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect4bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect4bPoints[2].x = (int)((rect4bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4bPoints[2].y = (int)((rect4bX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + 中心Y； \n  rect4bPoints[3].x = (int)(rect4bX - centerX) * cos(rotationAngle * M_PI / 180) + ((rect4bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4bPoints[3].y = (int)(rect4bX - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect4bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rect4bPoints, 4, 黑色); \n \n  // 修改第五個斜形（長度為120） \n  gdPoint rect5Points[4]; \n  int 矩形5X = 矩形4aX + 15 + 矩形間距； // 第五個長方形 \n  int 矩形5Y = 矩形4aY； \n  rect5Points[0].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) + (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect5Points[0].y = (int)(rect5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect5Points[1].x = (int)((rect5X + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect5Points[1].y = (int)((rect5X + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect5Points[2].x = (int)((rect5X + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect5Y + 120) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect5Points[2].y = (int)((rect5X + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect5Y + 120) - centerY) * cos(rotationAngle * M_PI / 180) + 中心Y； \n  rect5Points[3].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) + ((rect5Y + 120) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect5Points[3].y = (int)(rect5X - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect5Y + 120) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rect5Points, 4, 黑色); \n \n  //新增新的黑色斜形（第六個，上半部） \n  gdPoint rect6aPoints[4]; \n  int 矩形6aX = 矩形5X + 15 + 矩形間距； // 第六個長方形（上半部） \n  int 矩形6aY = 矩形5Y； \n  rect6aPoints[0].x = (int)(rect6aX - centerX) * cos(rotationAngle * M_PI / 180) + (rect6aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6aPoints[0].y = (int)(rect6aX - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect6aPoints[1].x = (int)((rect6aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect6aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6aPoints[1].y = (int)((rect6aX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect6aPoints[2].x = (int)((rect6aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6aPoints[2].y = (int)((rect6aX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + 中心Y； \n  rect6aPoints[3].x = (int)(rect6aX - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6aPoints[3].y = (int)(rect6aX - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rect6aPoints, 4, 黑色); \n \n  //新增新的黑色斜形（第六個，下半部） \n  gdPoint rect6bPoints[4]; \n  int 矩形6bX = 矩形5X + 15 + 矩形間距； // 第六個長方形（下半部） \n  int 矩形6bY = 矩形5Y + 55 + 10； // 上半部的 Y 座標 + 上半部的高度 + 間隔 \n  rect6bPoints[0].x = (int)(rect6bX - centerX) * cos(rotationAngle * M_PI / 180) + (rect6bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6bPoints[0].y = (int)(rect6bX - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect6bPoints[1].x = (int)((rect6bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + (rect6bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6bPoints[1].y = (int)((rect6bX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + (rect6bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect6bPoints[2].x = (int)((rect6bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6bPoints[2].y = (int)((rect6bX + 15) - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + 中心Y； \n  rect6bPoints[3].x = (int)(rect6bX - centerX) * cos(rotationAngle * M_PI / 180) + ((rect6bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6bPoints[3].y = (int)(rect6bX - centerX) * (-sin(rotationAngle * M_PI / 180)) + ((rect6bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rect6bPoints, 4, 黑色);} \n \n \n  //新增新的黑色斜形（第四個，上半部） \n  gdPoint rect4aPoints[4]; \n  int rect4aX = 460;  // 第四個長方形（上半部） \n  int rect4aY = 185; \n  rect4aPoints[0].x = (int)(rect4aX - centerX) * cos(rotationAngle * M_PI / 180) - (rect4aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4aPoints[0].y = (int)(rect4aX - centerX) * sin(rotationAngle * M_PI / 180) + (rect4aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect4aPoints[1].x = (int)((rect4aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - (rect4aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4aPoints[1].y = (int)((rect4aX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + (rect4aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect4aPoints[2].x = (int)((rect4aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect4aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4aPoints[2].y = (int)((rect4aX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect4aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect4aPoints[3].x = (int)(rect4aX - centerX) * cos(rotationAngle * M_PI / 180) - ((rect4aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4aPoints[3].y = (int)(rect4aX - centerX) * sin(rotationAngle * M_PI / 180) + ((rect4aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rect4aPoints, 4, 黑色); \n \n  //新增新的黑色斜形（第四個，下半部） \n  gdPoint rect4bPoints[4]; \n  int rect4bX = rect4aX;  // 使用與上半部相同的X座標 \n  int rect4bY = rect4aY + 55 + 10； // 上半部的 Y 座標 + 上半部的高度 + 間隔 \n  rect4bPoints[0].x = (int)(rect4bX - centerX) * cos(rotationAngle * M_PI / 180) - (rect4bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4bPoints[0].y = (int)(rect4bX - centerX) * sin(rotationAngle * M_PI / 180) + (rect4bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect4bPoints[1].x = (int)((rect4bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - (rect4bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4bPoints[1].y = (int)((rect4bX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + (rect4bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect4bPoints[2].x = (int)((rect4bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect4bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4bPoints[2].y = (int)((rect4bX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect4bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect4bPoints[3].x = (int)(rect4bX - centerX) * cos(rotationAngle * M_PI / 180) - ((rect4bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect4bPoints[3].y = (int)(rect4bX - centerX) * sin(rotationAngle * M_PI / 180) + ((rect4bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rect4bPoints, 4, 黑色); \n \n  // 修改第五個斜形（上方加） \n  gdPoint rect5Points[4]; \n  int 矩形5X = 矩形4aX + 15 + 矩形間距； // 第五個長方形 \n  int 矩形5Y = 矩形4aY； \n  int 中間矩形寬度 = 15;  // 中間長方形寬度 \n  int 中間矩形高度 = 55;  // 中間長方形高度 \n  int 中間矩形間距 = 10;  // 中間長方形兩邊間隔 \n  rect5Points[0].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) - (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect5Points[0].y = (int)(rect5X - centerX) * sin(rotationAngle * M_PI / 180) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect5Points[1].x = (int)((rect5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - (rect5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect5Points[1].y = (int)((rect5X + middleRectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + (rect5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  矩形點[2].x = (int)((矩形矩形寬度) - centerX) * cos(旋轉角度* M_PI / 180) - ((矩形矩形高度+ 矩形高度) - centerY) * sin(旋轉角度* M_PI / 180) + centerX; \n  rect5Points[2].y = (int)((rect5X + middleRectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) * cos_PI / 1800); \n  rect5Points[3].x = (int)(rect5X - centerX) * cos(rotationAngle * M_PI / 180) - ((rect5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect5Points[3].y = (int)(rect5X - centerX) * sin(rotationAngle * M_PI / 180) + ((rect5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rect5Points, 4, 黑色); \n \n \n  //新增位於第五個斜形下方的新的黑色斜形 \n  gdPoint rectBelow5Points[4]; \n  int rectBelow5X = rect5X; \n  int 矩形下方5Y = 矩形5Y + 中間矩形高度 + 中間矩形間距； \n  rectBelow5Points[0].x = (int)(rectBelow5X - centerX) * cos(rotationAngle * M_PI / 180) - (rectBelow5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rectBelow5Points[0].y = (int)(rectBelow5X - centerX) * sin(rotationAngle * M_PI / 180) + (rectBelow5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rectBelow5Points[1].x = (int)((rectBelow5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - (rectBelow5Y - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rectBelow5Points[1].y = (int)((rectBelow5X + middleRectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + (rectBelow5Y - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rectBelow5Points[2].x = (int)((rectBelow5X + middleRectWidth) - centerX) * cos(rotationAngle * M_PI / 180) - ((rectBelow5Y + middleRectHeight) - centerY) * sin(rotationAngle * MPIPIY + middleRectHeight) - centerY) * sin(rotation AAngle MPIPI +/Penter + ) +/AnX); \n  rectBelow5Points[2].y = (int)((rectBelow5X + middleRectWidth) - centerX) * sin(rotationAngle * M_PI / 180) + ((rectBelow5Y + middleRectHeight) - centerY) * cos(rotationAngle * MPI(rotation); \n  rectBelow5Points[3].x = (int)(rectBelow5X - centerX) * cos(rotationAngle * M_PI / 180) - ((rectBelow5Y + middleRectHeight) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rectBelow5Points[3].y = (int)(rectBelow5X - centerX) * sin(rotationAngle * M_PI / 180) + ((rectBelow5Y + middleRectHeight) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rectBelow5Points, 4, 黑色); \n \n  // 第六個斜形（上半部） \n  gdPoint rect6aPoints[4]; \n  int 矩形6aX = 矩形5X + 15 + 10； // 第六個長方形（上半部） \n  int 矩形6aY = 矩形5Y； \n  rect6aPoints[0].x = (int)(rect6aX - centerX) * cos(rotationAngle * M_PI / 180) - (rect6aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6aPoints[0].y = (int)(rect6aX - centerX) * sin(rotationAngle * M_PI / 180) + (rect6aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect6aPoints[1].x = (int)((rect6aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - (rect6aY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6aPoints[1].y = (int)((rect6aX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + (rect6aY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect6aPoints[2].x = (int)((rect6aX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect6aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6aPoints[2].y = (int)((rect6aX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect6aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect6aPoints[3].x = (int)(rect6aX - centerX) * cos(rotationAngle * M_PI / 180) - ((rect6aY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6aPoints[3].y = (int)(rect6aX - centerX) * sin(rotationAngle * M_PI / 180) + ((rect6aY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rect6aPoints, 4, 黑色); \n \n  // 第六個斜形（下半部） \n  gdPoint rect6bPoints[4]; \n  int rect6bX = rect6aX;  // 第六個長方形（下半部） \n  int 矩形 6bY = 矩形 6aY + 55 + 10； // 上半部的 Y 座標 + 上半部的高度 + 間隔 \n  rect6bPoints[0].x = (int)(rect6bX - centerX) * cos(rotationAngle * M_PI / 180) - (rect6bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6bPoints[0].y = (int)(rect6bX - centerX) * sin(rotationAngle * M_PI / 180) + (rect6bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect6bPoints[1].x = (int)((rect6bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - (rect6bY - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6bPoints[1].y = (int)((rect6bX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + (rect6bY - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect6bPoints[2].x = (int)((rect6bX + 15) - centerX) * cos(rotationAngle * M_PI / 180) - ((rect6bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6bPoints[2].y = (int)((rect6bX + 15) - centerX) * sin(rotationAngle * M_PI / 180) + ((rect6bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n  rect6bPoints[3].x = (int)(rect6bX - centerX) * cos(rotationAngle * M_PI / 180) - ((rect6bY + 55) - centerY) * sin(rotationAngle * M_PI / 180) + centerX; \n  rect6bPoints[3].y = (int)(rect6bX - centerX) * sin(rotationAngle * M_PI / 180) + ((rect6bY + 55) - centerY) * cos(rotationAngle * M_PI / 180) + centerY; \n \n  gdImageFilledPolygon(rotated_im, rect6bPoints, 4, 黑色); \n \n    輸出 = fopen("output.png", "wb"); \n    gdImagePng(rotated_im, 輸出); \n    fclose(輸出); \n \n    gdImageDestroy(im); \n    gdImageDestroy(rotated_im); \n \n    返回0； \n} \n \n \n', 'tags': '', 'url': 'w8.html'}, {'title': 'W9-10', 'text': '', 'tags': '', 'url': 'W9-10.html'}, {'title': 'W11-12', 'text': '＃包括 \n＃包括 \n＃包括 \n \nint main() { \nint 寬度 = 800; \n整數高度=600； \n \ngdImagePtr img = gdImageCreateTrueColor(寬度, 高度); \ngdImageAlphaBlending(img, 0); \n \nFILE *outputFile = fopen("hellogd.png", "wb"); \n如果（輸出檔== NULL）{ \n \nfprintf(stderr, "開啟輸出檔時發生錯誤。\\n"); \n \n返回1； \n} \n \nint 紅色 = gdImageColorAllocate(img, 255, 0, 0); \nint 藍色 = gdImageColorAllocate(img, 0, 0, 255); \nint black = gdImageColorAllocate(img, 0, 0, 0); \nint 白色 = gdImageColorAllocate(img, 255, 255, 255); \n// 長方形著色 \ngdImageFilledRectangle(img, 0, 0, 寬度, 高度, 白色); \ngdImageFilledRectangle(img, 0, 0, (int)width/4, (int)height/4, 藍色); \n// 曲面形著色 \ngdImageFilledEllipse(img, (int)寬度*3/4, (int)高度/4, (int)寬度/4, (int)寬度/4,紅色); \n// 圓形畫線 \ngdImageEllipse(img, (int)寬度*3/4, (int)高度*3/4, (int)寬度/4, (int)寬度/4,紅色); \n// 畫直線 \ngdImageLine(img, (int)width/2, (int)height/2, (int)width/2, (int)height/2 + 100, 藍色); \n \n// 施工畫線 \ngdPoint點[4]； \n點[0].x = (int)寬度/4; \n點[0].y = (int)高度*3/4; \n點[1].x = 點[0].x + 100； \n點[1].y = 點[0].y； \n點[2].x = 點[1].x； \n點[2].y = 點[1].y + 100 ； \n點[3].x = 點[2].x - 100； \n點[3].y = 點[2].y; \ngdImagePolygon(img, 點, 4, 黑色); \n \n// 廈門著色 \ngdPointpoints2[4]; \n點2[0].x = (int)寬度/3; \n點2[0].y = (int)高度/2; \n點2[1].x =點2[0].x + 100； \n點2[1].y = 點2[0].y; \n點2[2].x = 點2[1].x; \n點2[2].y = 點2[1].y + 100； \n點2[3].x = 點2[2].x - 150； \n點2[3].y = 點2[2].y; \ngdImageFilledPolygon(img, 點2, 4, 紅色); \n \ngdImagePngEx(img, 輸出檔, 9); \nfclose(輸出檔); \ngdImageDestroy(img); \n回傳0； \n} \n \n \n \n 先設定hello.c的檔 \n #include <stdio.h> \n \nint main() \n{ \nprintf("你好世界\\n"); \n} \n \n 然後再shell打cc hello.c會出現這個 \n \n 然後要回車這樣replit就會幫我準備好c \n 之後再進行一次程式 cc hello.c，然後打./a.out \n 然後就會出現hello world \n', 'tags': '', 'url': 'W11-12.html'}, {'title': 'w13', 'text': '布萊頓 \n https://en.wikipedia.org/wiki/Python_（程式語言） \n 例子： \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python教學： \n https://docs.python.org/3/tutorial/ \n Python的平衡介紹 \n 縮排（Python採用4個Spaces縮排，以介面執行範圍） \n 變數（ Python 關鍵字 ） \n 註（#單行註解、三單標註或三雙標註標註多行註解） \n 數 (整數 int(), 浮點數 float()) \n 字串 （字符串） \n print (Python 內建函數,  print() 函數式) \n Python是控制流程工具 \n 為了 \n 如果 \n 範圍 \n 開放 \n 讀 \n 清單 \n 元組 \n 字典 \n 功能 \n 嘗試...除了 \n 休息時間 \n 曾經 \n 類別 \n 此頁面示範如何在同一頁面下加入多個線上Ace編輯器與執行按鈕（ practice_html.txt 動態頁面超檔案）。 \n Practice_html.txt 動態頁面超檔案應該可以在啟動Brython時，設定分割.py檔案放入downloads/py目錄中的參考。 \n 也所有出現的反html也使用Brython產生，編寫成 類別 後，在範例匯入時交叉< ai=3>實例 引用。 \n \n<腳本> \n視窗.onload=函數(){ \nbrython({ 調試:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']}); \n} \n</> 腳本 \n 從1累加到100： \n 1加到100 \n 將iterable與iterator 相關說明 ，利用Brython與Ace Editor整理頁面。 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n 文件名稱： .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n 跑步   輸出   明確輸出區 清晰的繪圖區 重新載入 \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從1累加到100第2部分： \n 1加到100 cango_三_齒輪 BS蛇 人工智慧俄羅斯區塊鏈 旋轉塊 \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n 文件名稱： .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n 跑步   輸出   明確輸出區 清晰的繪圖區 重新載入 \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n', 'tags': '', 'url': 'w13.html'}]};