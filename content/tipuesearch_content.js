var tipuesearch = {"pages": [{'title': '關於', 'text': 'https://github.com/mdecycu/cmsite \n', 'tags': '', 'url': '關於.html'}, {'title': 'w6', 'text': '// 包含標準輸出入程式庫的標頭檔 // https://blog.csdn.net/weixin_38468077/article/details/101069365 // http://www.gnuplot.info/demo/ // https:/ /https:// /https:// /https:///github.com/sysprog21/rv32emu // https://github.com/sysprog21/semu // https://docs.google.com/presentation/ d/14N0cWG2SnBSqhc2cLF0_2VerB9FF8JN3 // https://cs61c .org/fa23/ // https://greenteapress.com/wp/think-python-2e/ // https://github.com/ecalvadi/c99-examples // https://github .com/gouravthakur39/初學者-C-program -examples // https://github.com/ergenekonyigit/Numerical-Analysis-Examples // https://www.che.ncku.edu.tw /facultyweb/changct/ html/teaching/CPPandMATLAB/ Past/pdf%20Files /Chap02-Ling.pdf // https://gteceducation.com.com.com/Brochures/PROGRAMMING/C%20PROGRAMMING%20FULL.pdf // https:/sg.pdf // https:/sg /jsommers.github。io/cbook/cbook. \xa0 pdf // https://jsomers.github.io/cbook/index.html // http://student.itee.uq.edu.au/courses/csse2310/CProgrammingNotes.pdf // http ://cslibrary.stanford .edu/101/ EssentialC.pdf // https://publications.gbdirect.co.uk/c_book/ // https://www.fossil-scm.org/fossil-book/doc/ 2ndEdition/fossilbook.pdf // **** * 在replit 執行 // cd 下載 // cc gnuplot_ex1.c -o gnuplot_ex1 // ./gnuplot_ex1 #include <stdio.h> \n //\xa0 int main() { //popen 啟動 Gnuplot 程式 FILE *gnuplotPipe = popen("gnuplot -persistent", "w"); if (!gnuplotPipe) { fprintf(stderr, "啟動Gnuplot失敗。\\n"); 回傳1； } \n // 使用 G pclose(gnuplotPipe); \n 返回0； } \n \xa0 \n', 'tags': '', 'url': 'w6.html'}, {'title': 'w7', 'text': '\n // https://en.wikipedia.org/wiki/Flag_of_thcp2023.a0968899313.repl.coe_Republic_of_China\n// cc roc_flag.c -lgd -lm 連接gd與數學庫\n// https://www.rapidtables.com/ web/ color/RGB_Color.html\n// 幾何形狀著色與繪圖練習\n//以下gd繪畫教學嘗試類似的中華民國國旗，請根據以下計劃內容完成後續的國旗綁定\n#include <stdio.h>\n#include <gd.h >\n#包括 <math.h>\n\nvoiddraw_roc_flag（gdImagePtr img）；\nvoid draw_white_sun(gdImagePtr img, int x, int y, int size, int color);\n\nint main() {\n// 寬度 3: 高度 2\nint width = 1200;\nint 高度 = (int)(寬度*2.0 / 3.0);\n\ngdImagePtr img = gdImageCreateTrueColor(寬度, 高度);\ngdImageAlphaBlending(img, 0);\n\n鄰近_roc_flag（img）；\n\nFILE *outputFile = fopen("./../images/roc_flag.png", "wb");\nif (outputFile == NULL) {\nfprintf(stderr, "開啟輸出檔時發生錯誤。\\n");\n回傳1；\ngdImagePngEx\n(img, 輸出檔, 9);\nfclose(輸出檔);\ngdImageDestroy(img);\n回傳0；\n}\n\ndrawroVinc_flag（gdImagePtr img）{\nint寬度= gdImageSX（img）;\nint 高度 = gdImageSY(img);\nint 紅、白、藍；\nint center_x = (int)(寬度/4);\nint center_y = (int)(高度/4);\nint sun_radius = (int)(寬度/8);\n// 標誌的顏色\nred = gdImageColorAllocate(img, 242, 0, 0); //\n紅白 = gdImageColorAllocate(img, 255, 255, 255); // 白色條紋\n藍色 = gdImageColorAllocate(img, 0, 41, 204); // 藍色\n// 紅色自訂區域\ngdImageFilledRectangle(img, 0, 0, width, height, red);\n// 藍色區域\ngdImageFilledRectangle(img, 0, 0, (int)(width/2.0), (int)(height/2.0), blue);\n// 目前只出青天白日的直線，請嘗試計算所需的點座標完成國旗繪圖\ndraw_white_sun(img, center_x, center_y, sun_radius, White);\n}\n\nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int color) {\n浮動角度 = 0;\nint fromX, fromY;\nint toX, toY;\nfor (int i=0; i<24; i++){\n角度 += 5*M_PI*2/12;\n//printf("%.3f", 角度);\ntoX = center_x + cos(角度)*sun_radius;\ntoY = center_y + sin(角度)*sun_radius;\n// 允許i為0時移動到toX, toY，其餘都進行直線起重機\nif (i!=0){\ngdImageLine(img, fromX, fromY, toX, toY, color);\n}\n從X = 到X;\n從Y = 到Y;\n}\n}\n\n \n \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nvoid draw_usa_flag(gdImagePtr img);\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle);\n\nint main() {\n    int width = 800;\n    int height = (int)(width / 1.9);\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    draw_usa_flag(img);\n\n    FILE *outputFile = fopen("./../images/usa_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "打开输出文件时出错。\\n");\n        return 1;\n    }\n\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n\n    return 0;\n}\n\nvoid draw_usa_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white, blue;\n    // 国旗颜色\n    red = gdImageColorAllocate(img, 178, 34, 52); // 红色条纹\n    white = gdImageColorAllocate(img, 255, 255, 255); // 白色条纹\n    blue = gdImageColorAllocate(img, 60, 59, 110); // 蓝色矩形\n\n    int stripe_height = height / 13;\n    int stripe_width = width;\n    int star_size = (int)(0.0308 * height); // 星星大小\n\n    for (int y = 0; y < height; y += stripe_height) {\n        if (y / stripe_height % 2 == 0) {\n            gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, red);\n        } else {\n            gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, white);\n        }\n    }\n\n    gdImageFilledRectangle(img, 0, 0, width * 2 / 5, stripe_height * 7, blue);\n\n    int star_spacing_x = (int)(0.129 * height); // 横向星星之间的间距\n    int star_spacing_y = (int)(0.054 * height); // 纵向星星之间的间距\n    int star_start_x = (int)(0.125 * height); // 星星的起始X位置\n    int star_start_y = (int)(0.0485 * height); // 星星的起始Y位置\n\n    for (int row = 0; row < 9; row++) {\n        int starsPerRow = (row % 2 == 0) ? 6 : 5;\n\n        // 计算2、4、6和8排星星的偏移量\n        int offset_x = (row % 2 == 0) ? star_spacing_x / -2 : 0;\n\n        for (int star = 0; star < starsPerRow; star++) {\n            int x = star_start_x + star * star_spacing_x + offset_x;\n\n            // 旋转角度（以弧度为单位）\n            double rotation_angle = M_PI / 5; // 忘記多少度的旋转\n\n            int y = star_start_y + row * star_spacing_y;\n            draw_star(img, x, y, star_size, white, rotation_angle);\n        }\n    }\n}\n\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle) {\n    gdPoint points[10];\n\n    for (int i = 0; i < 10; i++) {\n        double angle = M_PI / 2 + i * 2 * M_PI / 10 + rotation_angle;\n        int radius = (i % 2 == 0) ? size : size / 2;\n        points[i].x = x + radius * cos(angle);\n        points[i].y = y + radius * sin(angle);\n    }\n\n    // 用指定的颜色填充星星\n    gdImageFilledPolygon(img, points, 10, color);\n} \n \n \n \n \n \n', 'tags': '', 'url': 'w7.html'}, {'title': 'w8', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <stdlib.h>\n\n無效drawJapanFlag() {\nint width = 300; //寬度\nint高度=200; // 高度\nint 半徑 = 50; // 貨物半徑\nint centerX = 150; // 交易中心X座標\nint centerY = 100; // 訂單中心Y座標\n\n// 建立一個24位元的彩色圖片\ngdImagePtr im = gdImageCreateTrueColor(width, height);\n\n// 設定背景色為白色\nint white = gdImageColorAllocate(im, 255, 255, 255);\ngdImageFill(im, 0, 0, 白色);\n\n// 設定需求的顏色為紅色\nint red = gdImageColorAllocate(im, 255, 0, 0);\n\n// 畫紅色浪漫\ngdImageFilledEllipse(im, centerX, centerY, 2 * radius, 2 * radius, red);\n\n// 輸出圖片到file\n檔 *output = fopen("japanese_flag.png", "wb");\nif (output == NULL) {\nfprintf(stderr, "無法開啟檔案寫入。\\n");\n退出（EXIT_FAILURE）；\n}\n\ngdImagePng(im, 輸出);\n\n// 釋放記憶體\ngdImageDestroy(im);\nfclose(輸出);\n}\n\nint main() {\n繪製日本國旗();\nprintf("創建日本國旗：japanese_flag.png\\n");\n返回0；\n}\n\n \n \n \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle);\nvoid draw_chinese_flag(gdImagePtr img);\n\nint main() {\nint width = 300; // 國旗寬度\nint height = 200; // 國旗高度\n\ngdImagePtr im = gdImageCreateTrueColor(width, height);\ngdImageAlphaBlending(im, 0);\n\ndraw_chinese_flag(im);\n\nFILE *outputFile = fopen("./../images/proc_flag.png", "wb");\nif (outputFile == NULL) {\nfprintf(stderr, "打開輸出文件時出錯。\\n");\nreturn 1;\n}\n\ngdImagePngEx(im, outputFile, 9);\nfclose(outputFile);\ngdImageDestroy(im);\n\nreturn 0;\n}\n\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle) {\ngdPoint points[10];\n\ndouble outer_radius = size / 2;\ndouble inner_radius = size / 6;\ndouble angle = M_PI / 5.0;\n\nfor (int i = 0; i < 10; i++) {\ndouble radius = (i % 2 == 0) ? outer_radius : inner_radius;\ndouble theta = rotation_angle + i * angle;\npoints[i].x = x + radius * cos(theta);\npoints[i].y = y + radius * sin(theta);\n}\n\ngdImageFilledPolygon(img, points, 10, color);\n}\n\nvoid draw_chinese_flag(gdImagePtr img) {\nint width = gdImageSX(img);\nint height = gdImageSY(img);\nint red, yellow;\n\nred = gdImageColorAllocate(img, 255, 0, 0); // 紅色背景\nyellow = gdImageColorAllocate(img, 255, 255, 0); // 黃色星星\n\ngdImageFilledRectangle(img, 0, 0, width, height, red);\n\nint star_size = (int)(0.28 * height);\nint star_x = (int)(0.165 * width);\nint star_y = (int)(0.265 * height);\n\ndraw_star(img, star_x, star_y, star_size, yellow, 11.0);\n\ndouble radius = 0.15 * height;\ndouble angle = 360 / 7 * M_PI / 179.0;\ndouble rotation = -M_PI / 7.5;\nint cx = (int)(0.32 * width);\nint cy = (int)(0.27 * height);\n\nfor (int i = -1; i < 3; i++) {\nint x = (int)(cx + radius * cos(i * angle + rotation));\nint y = (int)(cy + radius * sin(i * angle + rotation));\ndraw_star(img, x, y, 19, yellow, M_PI / 5.0);\n}\n}\n\n \n \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nvoid draw_uk_flag(gdImagePtr img);\nvoid fillTriangle(gdImagePtr img, int x1, int y1, int x2, int y2, int x3, int y3, int color);\n\nint main() {\nint width = 1200;\nint height = width / 2;\n\ngdImagePtr img = gdImageCreateTrueColor(width, height);\ngdImageAlphaBlending(img, 0);\n\ndraw_uk_flag(img);\n\nFILE *outputFile = fopen("./../images/uk_flag.png", "wb");\nif (outputFile == NULL) {\nfprintf(stderr, "打開輸出文件時發生錯誤。\\n");\nreturn 1;\n}\n\ngdImagePngEx(img, outputFile, 9);\nfclose(outputFile);\ngdImageDestroy(img);\n\nreturn 0;\n}\n\nvoid draw_uk_flag(gdImagePtr img) {\nint width = gdImageSX(img);\nint height = gdImageSY(img);\n\nint red, white, blue;\nred = gdImageColorAllocate(img, 204, 0, 0);\nwhite = gdImageColorAllocate(img, 255, 255, 255);\nblue = gdImageColorAllocate(img, 0, 0, 153);\n\ngdImageFilledRectangle(img, 0, 0, width, height, blue);\n\n// 繪製斜線\n{\nint line_thickness = 100;\ngdImageSetThickness(img, line_thickness);\n\n// 繪製白色斜線\nint x1 = 0, y1 = 600, x2 = 1200, y2 = 0;\ngdImageLine(img, x1, y1, x2, y2, white);\n\nx1 = 0, y1 = 0, x2 = 1200, y2 = 600;\ngdImageLine(img, x1, y1, x2, y2, white);\n}\n\n// 繪製紅色斜線\n{\nint line_thickness = 33;\ngdImageSetThickness(img, line_thickness);\n\n// 繪製紅色斜線\nint x1 = 566, y1 = 300, x2 = 1166, y2 = 0;\ngdImageLine(img, x1, y1, x2, y2, red);\n\nx1 = 1233, y1 = 600, x2 = 633, y2 = 300;\ngdImageLine(img, x1, y1, x2, y2, red);\n\nx1 = 566, y1 = 300, x2 = -33, y2 = 0;\ngdImageLine(img, x1, y1, x2, y2, red);\n\nx1 = 600, y1 = 316.5, x2 = 0, y2 = 616.5;\ngdImageLine(img, x1, y1, x2, y2, red);\n}\n\n// 繪製白色斜線\n{\nint line_thickness = 33;\ngdImageSetThickness(img, line_thickness);\n\n// 繪製斜線\nint x1 = 0, y1 = 600, x2 = 1200, y2 = 0;\ngdImageLine(img, x1, y1, x2, y2, red);\n\nx1 = 1200, y1 = 16.5, x2 = 600, y2 = 316.5;\ngdImageLine(img, x1, y1, x2, y2, white);\n\nx1 = 0, y1 = 583.5, x2 = 600, y2 = 283.5;\ngdImageLine(img, x1, y1, x2, y2, white);\n}\n\n// 繪製白色十字\nint cross_width = width / 32;\nint cross_arm_width = width / 32;\nint center_x = width / 2;\nint center_y = height / 2;\n\ngdImageFilledRectangle(img, center_x + 2.7 * cross_width, 0, center_x - 2.7 * cross_width, height, white);\ngdImageFilledRectangle(img, 0, center_y + 2.7 * cross_arm_width, width, center_y - 2.7 * cross_arm_width, white);\n\n// 繪製紅色十字\ngdImageFilledRectangle(img, center_x + 1.5 * cross_width, 0, center_x - 1.5 * cross_width, height, red);\ngdImageFilledRectangle(img, 0, center_y + 1.5 * cross_arm_width, width, center_y - 1.5 * cross_arm_width, red);\n}\n\n \n \n #include <stdio.h>\n#include <gd.h>\n\nint main() {\n    // Create a new GD image (French flag dimensions: 900x600)\n    gdImagePtr im = gdImageCreateTrueColor(900, 600);\n\n    // Define colors (RGB format)\n    int blue = gdImageColorAllocate(im, 0, 0, 255);\n    int white = gdImageColorAllocate(im, 255, 255, 255);\n    int red = gdImageColorAllocate(im, 255, 0, 0);\n\n    // Draw vertical stripes (3 equal-width stripes)\n    int stripeWidth = 900 / 3;\n    gdImageFilledRectangle(im, 0, 0, stripeWidth - 1, 599, blue);\n    gdImageFilledRectangle(im, stripeWidth, 0, 2 * stripeWidth - 1, 599, white);\n    gdImageFilledRectangle(im, 2 * stripeWidth, 0, 899, 599, red);\n\n    // Save the image to a file\n    FILE *outputFile = fopen("french_flag.png", "wb");\n    gdImagePng(im, outputFile);\n    fclose(outputFile);\n\n    // Free the GD image\n    gdImageDestroy(im);\n\n    return 0;\n}\n \n \n w 9\n', 'tags': '', 'url': 'w8.html'}, {'title': 'w10', 'text': '', 'tags': '', 'url': 'w10.html'}, {'title': 'w11-12', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nint main() {\nint 寬度 = 800;\n整數高度=600；\n\ngdImagePtr img = gdImageCreateTrueColor(寬度, 高度);\ngdImageAlphaBlending(img, 0);\n\nFILE *outputFile = fopen("hellogd.png", "wb");\n如果（輸出檔案== NULL）{\n\nfprintf(stderr, "開啟輸出檔時發生錯誤。\\n");\n\n返回1；\n}\n\nint 紅色 = gdImageColorAllocate(img, 255, 0, 0);\nint 藍色 = gdImageColorAllocate(img, 0, 0, 255);\nint black = gdImageColorAllocate(img, 0, 0, 0);\nint 白色 = gdImageColorAllocate(img, 255, 255, 255);\n// 長方形塗色\ngdImageFilledRectangle(img, 0, 0, width, height, white);\ngdImageFilledRectangle(img, 0, 0, (int)width/4, (int)height/4, 藍色);\n// 曲面形著色\ngdImageFilledEllipse(img, (int)width*3/4, (int)height/4, (int)width/4, (int)width/4, red);\n// 圓形畫線\ngdImageEllipse(img, (int)width*3/4, (int)height*3/4, (int)width/4, (int)width/4, red);\n// 畫直線\ngdImageLine(img, (int)width/2, (int)height/2, (int)width/2, (int)height/2 + 100, blue);\n\n// 施工畫線\ngdPoint points[4];\n點[0].x = (int)寬度/4;\n點[0].y = (int)高度*3/4;\n點[1].x = 點[ 0].x + 100；\n點[1].y = 點[0].y；\n點[2].x = 點[1].x；\n點[2].y = 點[1].y + 100 ；\n點[3].x = 點[2].x - 100；\n點[3].y = 點[2].y;\ngdImagePolygon(img, 點, 4, 黑色);\n\n// 廈門著色\ngdPointpoints2[4];\n點2[0].x = (int)寬度/3;\n點2[0].y = (int)高度/2;\n點2[1].x =點2[ 0].x + 100；\n點2[1].y = 點2[0].y;\n點2[2].x = 點2[1].x;\n點2[2].y = 點2[ 1].y + 100；\n點2[3].x = 點2[2].x - 150；\n點2[3].y = 點2[2].y;\ngdImageFilledPolygon(img, 點2, 4, 紅色);\n\ngdImagePngEx(img, 輸出檔, 9);\nfclose(輸出檔);\ngdImageDestroy(img);\n回傳0；\n}\n\n \n \n', 'tags': '', 'url': 'w11-12.html'}, {'title': 'w13', 'text': '布萊頓 \n https://en.wikipedia.org/wiki/Python_（程式語言） \n 例子： \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python教學： \n https://docs.python.org/3/tutorial/ \n Python的平衡介紹 \n 縮排（Python採用4個Spaces縮排，以介面執行範圍） \n 變數（ Python 關鍵字 ） \n 註（#單行註解、三單標註或三雙標註標註多行註解） \n 數 (整數 int(), 浮點數 float()) \n 字符串 （字串） \n print (Python 內建函數,  print() 函數式) \n Python是控制流程工具 \n 為了 \n 如果 \n 範圍 \n 開放 \n 讀 \n 清單 \n 元組 \n 字典 \n 功能 \n 嘗試...除了 \n 休息時間 \n 曾經 \n 類別 \n 此頁面示範如何在同一頁面下加入多個線上Ace編輯器與執行按鈕（ practice_html.txt 動態頁面超檔案）。 \n Practice_html.txt 動態頁面超檔案應該可以在啟動Brython時，設定分割.py檔案放入downloads/py目錄中的參考。 \n 也所有即將出現的對應 html 也使用 Brython 產生，然後編寫為 類別 後，在範例匯入時交叉 實例 引用。 \n <!-- 啟動 Brython --> \n<腳本> \n視窗.onload=函數(){ \nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']}); \n} \n</> 腳本 \n 從1累加到100： \n 1加到100 \n 將 iterable 與 iterator 相關說明 ，利用 Brython 與 Ace Editor 整理頁面。 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n 文件名稱： .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n 跑步   輸出   明確輸出區 清晰的繪圖區 重新載入 \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從1累加到100第2部分： \n 1加到100 cango_三_齒輪 BS蛇 人工智能俄羅斯區塊鏈 旋轉塊 \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n 文件名稱： .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n 跑步   輸出   明確輸出區 清晰的繪圖區 重新載入 \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n', 'tags': '', 'url': 'w13.html'}]};